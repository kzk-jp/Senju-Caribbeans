<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>カリビアンズ 加入チャート</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb;
            color: white;
        }

        #chart-container {
            width: 100%;
            overflow: auto; /* 縦方向・横方向のスクロールを有効に */
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem; /* コンテナ内のパディング */
            box-sizing: border-box;
            border: 2px solid blue; /* ★診断用: コンテナに枠線を追加★ */
            /* height: 500px; */ /* ★もし固定高さが設定されている場合はコメントアウトまたは削除★ */
        }

        svg {
            display: block; /* Ensure svg is a block element */
            margin: auto; /* Center the svg if smaller than container */
            background-color: #e0e0e0; /* ★診断用: SVG領域に薄い背景色 (確認後削除可)★ */
            /* min-widthとmin-heightは削除 */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 100px;
            box-sizing: border-box;
            text-align: center; /* Center text within the card */
        }

        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 4px;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            background-color: #eee; /* Placeholder background */
        }

        .node-name {
            font-size: 10px;
            font-weight: 500;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden; /* Hide overflow text */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
            max-width: 90px;
            word-break: break-word;
        }

        .node-name a {
            text-decoration: none;
            color: #333;
        }

        .link {
            fill: none;
            stroke: #94a3b8;
            stroke-width: 1.2px;
        }
        /* 各ツリー間の余白 */
        .tree-group {
            margin-bottom: 40px; /* ツリーの下に余白を追加 */
        }
         /* 単独ノード用のグループクラス */
        .single-node-group {
             margin-bottom: 40px; /* 単独ノードの下に余白を追加 */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>カリビアンズ 加入チャート</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
        <div id="loading-message" style="text-align: center; padding: 20px;">データを読み込み中...</div>
    </div>

    <script>
        // JSONファイルを相対パスで読み込む (GASスクリプトが出力するフラットなJSON)
        const JSON_FILE_PATH = 'tree_data.json'; // ★GASスクリプトのGITHUB_FILE_PATHと同じパスに置き換えてください★

        d3.json(JSON_FILE_PATH).then(function(flatData) { // フラットなデータとして読み込む
            const container = document.getElementById("chart-container");
            const svgElement = document.getElementById("tree-svg");

            console.log("Loaded flatData:", flatData);

            d3.select("#loading-message").remove();

            // JSONデータが配列であることを確認
            if (!Array.isArray(flatData) || flatData.length === 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">エラー: データの形式が不正です、またはデータがありません。</div>`);
                return;
            }

            // ★ここから修正: フラットなデータから階層構造を構築★
            const nodesById = new Map(flatData.map(node => [node.id, node])); // IDをキーとしたマップを作成
            const rootNodes = []; // ルートノードを格納する配列
            const allChildrenIds = new Set(); // 子として追加されたノードのIDを記録

            // 各ノードを処理し、親子関係を構築
            flatData.forEach(node => {
                // children配列の初期化は、子を追加する親ノードでのみ行う
                // node.children = []; // ★この行は削除済み★

                // introducerPageIdが存在し、かつそのIDを持つ親ノードがデータ内に存在する場合
                if (node.introducerPageId && nodesById.has(node.introducerPageId)) {
                    const parent = nodesById.get(node.introducerPageId);
                    // 親ノードに子として追加
                    if (!parent.children) {
                         parent.children = []; // 親のchildren配列が存在しない場合のみ初期化
                    }
                    parent.children.push(node);
                    allChildrenIds.add(node.id); // 子として追加されたノードのIDを記録
                }
                // introducerPageIdがない、または親ノードが見つからないノードは、
                // 後でallChildrenIdsに含まれていないものだけを真のルートとする
            });

            // 真のルートノードを特定 (introducerPageIdがない、または親が見つからず、かつ他のノードの子になっていないもの)
            flatData.forEach(node => {
                if (!node.introducerPageId || !nodesById.has(node.introducerPageId)) {
                     // introducerPageIdがない、または親が見つからないノード
                     if (!allChildrenIds.has(node.id)) {
                         // かつ、他のノードの子になっていない場合、真のルートとする
                         rootNodes.push(node);
                     } else {
                         // introducerPageIdがない、または親が見つからないが、なぜか他のノードの子になっている場合 (データ構造の異常)
                         console.warn(`Node ${node.name} (ID: ${node.id}) has no parent or parent not found, but is listed as a child. Skipping as root.`);
                     }
                }
            });


            console.log("Built hierarchy roots:", rootNodes);

            // 構築された階層構造のルートが空の場合
            if (rootNodes.length === 0 && flatData.length > 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">エラー: ルートノードが見つかりませんでした。データ構造を確認してください。</div>`);
                 return;
            } else if (rootNodes.length === 0 && flatData.length === 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">データがありません。</div>`);
                 return;
            }


            // ノード間の間隔を調整 (縦型レイアウト向け)
            const dx = 250; // 横方向の間隔 (ノードカードの幅 + 余白)
            const dy = 110; // 縦方向の間隔 (ノードカードの高さ + 余白)

            const margin = { top: 40, right: 40, bottom: 40, left: 40 }; // marginの定義

            const svg = d3.select("#tree-svg");
            let totalSvgHeight = 0; // 全てのツリーを合わせたSVGの高さ
            let maxTreeWidth = 0; // 全てのツリーの中で最も横幅を取るツリーの幅

            // 各ルートノード（各独立したツリー）に対して描画処理
            rootNodes.forEach((rootData, index) => {
                 // Calculate layout and dimensions for the current tree/node first
                 let subtreeWidth = 0;
                 let subtreeHeight = 0;
                 let minY = 0; // Default for single node
                 let maxY = 0; // Default for single node
                 let root = null;
                 const nodeCardWidth = 100; // Consistent node card width
                 const nodeCardHeight = 80; // Consistent node card height

                 if (rootData.children && rootData.children.length > 0) {
                     console.log(`Calculating layout for tree root: ${rootData.name}`);
                     root = d3.hierarchy(rootData);
                     const treeLayout = d3.tree().nodeSize([dy, dx]); // dyは縦方向の間隔, dxは横方向の間隔
                     treeLayout(root);

                     let minX = Infinity, maxX = -Infinity;
                     root.each(d => {
                         minX = Math.min(minX, d.x);
                         maxX = Math.max(maxX, d.x);
                         minY = Math.min(minY, d.y); // 横方向の最小位置
                         maxY = Math.max(maxY, d.y); // 横方向の最大位置
                     });
                     subtreeWidth = maxY - minY;
                     subtreeHeight = maxX - minX;

                 } else {
                      console.log(`Calculating layout for single node: ${rootData.name}`);
                      // Single node dimensions
                      subtreeWidth = nodeCardWidth;
                      subtreeHeight = nodeCardHeight;
                      minY = -nodeCardWidth / 2; // Align with node-card x position (-50)
                      maxY = nodeCardWidth / 2;  // Align with node-card x position + width (50)
                 }

                 // Update max tree width for SVG width calculation
                 maxTreeWidth = Math.max(maxTreeWidth, subtreeWidth);


                 const g = svg.append("g")
                     .attr("class", rootData.children && rootData.children.length > 0 ? "tree-group" : "single-node-group") // Different class for single nodes
                     // 各要素を縦に並べるように配置
                     // 横方向は要素の左端をSVGの左マージンに合わせる
                     .attr("transform", `translate(${margin.left - minY}, ${totalSvgHeight + margin.top})`); // 横方向を左端寄せ, 縦方向は累計高さ

                 if (rootData.children && rootData.children.length > 0) {
                     // Draw links and nodes for trees
                     g.append("g")
                         .attr("fill", "none")
                         .attr("stroke-linejoin", "round")
                         .attr("stroke-linecap", "round")
                         .selectAll("path")
                         .data(root.links())
                         .join("path")
                         .attr("class", "link")
                         // 縦型レイアウト用のリンクパス
                         .attr("d", d3.linkVertical()
                             .x(d => d.x) // d.x が横方向の位置になる
                             .y(d => d.y)); // d.y が縦方向の位置になる


                     const node = g.append("g")
                         .selectAll("g")
                         .data(root.descendants())
                         .join("g")
                         .attr("transform", d => {
                             console.log("Drawing node:", d.data.name, "at", d.x, d.y); // ★診断用ログ★
                             return `translate(${d.x},${d.y})`;
                         });

                     node.append("foreignObject")
                         .attr("x", -nodeCardWidth / 2) // ノードの中心に合わせる (ノードカード幅の半分)
                         .attr("y", -nodeCardHeight / 2) // ノードの中心に合わせる (ノードカード高さの半分)
                         .attr("width", nodeCardWidth)
                         .attr("height", nodeCardHeight)
                         .append("xhtml:div")
                         .attr("class", "node-card")
                         .html(d => `
                             ${d.data.image ? `<img class="node-image" src="${d.data.image}" alt="${d.data.name} photo">` : '<div class="node-image" style="background-color: #ccc; display: flex; align-items: center; justify-content: center; font-size: 10px;">No Image</div>'}
                             <div class="node-name">
                                 ${d.data.page_url ? `<a href="${d.data.page_url}" target="_blank">${d.data.name}</a>` : d.data.name}
                             </div>
                         `);

                      // Optional: Add tooltips for introduction reason
                      node.append("title")
                          .text(d => d.data.introduction_reason ? `紹介理由: ${d.data.introduction_reason}` : '');

                 } else {
                     // Draw single node
                      const g = svg.append("g") // 単独ノードは別のグループに追加
                           .attr("class", "single-node-group")
                           // 横方向は左端寄せ、縦方向は累計高さ
                           .attr("transform", `translate(${margin.left}, ${totalSvgHeight + margin.top})`);

                      g.append("foreignObject")
                          .attr("x", 0) // グループの原点(左端)基準
                          .attr("y", 0) // グループの原点(上端)基準
                          .attr("width", nodeCardWidth)
                          .attr("height", nodeCardHeight)
                          .append("xhtml:div")
                          .attr("class", "node-card")
                          .html(`
                              ${rootData.image ? `<img class="node-image" src="${rootData.image}" alt="${rootData.name} photo">` : '<div class="node-image" style="background-color: #ccc; display: flex; align-items: center; justify-content: center; font-size: 10px;">No Image</div>'}
                              <div class="node-name">
                                  ${rootData.page_url ? `<a href="${rootData.page_url}" target="_blank">${rootData.name}</a>` : rootData.name}
                              </div>
                          `);
                      g.append("title").text(rootData.introduction_reason ? `紹介理由: ${rootData.introduction_reason}` : '');
                 }


                 // Update total height (stacking vertically)
                 totalSvgHeight += subtreeHeight + margin.bottom;

            });

            // 全てのツリーを描画した後でSVG全体の高さを設定
            svg.attr("height", totalSvgHeight + margin.top); // 最後のツリーの下にも余白を追加

            // SVGの幅を、全てのツリーの中で最も横幅を取るツリーに合わせて設定
            const svgWidth = maxTreeWidth + margin.left + margin.right;
            svg.attr("width", svgWidth);


            // 横方向のスクロール位置を調整
            if (container) {
                 const containerCenter = container.clientWidth / 2;
                 // SVGの幅がコンテナ幅より大きい場合、中央にスクロール
                 if (svgWidth > container.clientWidth) {
                    container.scrollLeft = (svgWidth / 2) - containerCenter;
                 } else {
                     // SVGがコンテナ幅より小さい場合、左端にスクロール（または中央寄せ）
                     container.scrollLeft = 0; // 左端に揃える
                     // もし中央寄せしたい場合は以下を使用:
                     // container.scrollLeft = (container.clientWidth - svgWidth) / 2;
                 }
            }


        }).catch(function(error) {
            // JSONファイルの読み込みまたはパースに失敗した場合
            console.error("Error loading or parsing JSON:", error);
            d3.select("#loading-message").remove(); // ローディングメッセージを削除
            d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">データの読み込みに失敗しました。<br>詳細: ${error.message || error}</div>`);
        });
    </script>
</body>
</html>
