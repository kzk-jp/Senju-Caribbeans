<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>フットサルメンバー紹介ツリー（D3.js版）</title>
    <style>
        /* Basic body styling */
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            color: #333; /* Dark gray text */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            height: 100vh; /* Full viewport height */
        }

        /* Header styling */
        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* Tailwind blue-700 */
            color: white;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        /* Search container styling */
        #search-container {
            text-align: center;
            padding: 10px;
            background-color: #e5e7eb; /* Tailwind gray-200 */
            border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 */
            flex-shrink: 0; /* Prevent search bar from shrinking */
            position: relative; /* For suggestion box positioning */
        }

        /* Wrapper for input and suggestions for better layout control */
        .search-input-wrapper {
            position: relative;
            display: inline-block;
            width: 280px; /* Adjust width as needed */
            vertical-align: middle; /* Align with button */
        }

        #search-container input[type="text"] {
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 1rem;
            width: 100%; /* Fill the wrapper */
            box-sizing: border-box;
        }

        #search-container button {
            padding: 8px 15px;
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
            margin-left: 5px; /* Space between input wrapper and button */
            vertical-align: middle; /* Align with input wrapper */
        }

        #search-container button:hover {
            background-color: #2563eb; /* Tailwind blue-700 */
        }

        /* Suggestions container styling */
        #suggestions-container {
            position: absolute;
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-top: none;
            z-index: 1000;
            max-height: 150px;
            overflow-y: auto;
            width: 100%; /* Match wrapper width */
            left: 0;
            top: 100%; /* Position it right below the input */
            box-sizing: border-box;
            display: none; /* Initially hidden */
            text-align: left; /* Align text to the left for readability */
        }

        .suggestion-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #333;
        }

        .suggestion-item:hover {
            background-color: #e0e0e0; /* Lighter gray for hover */
        }


        /* Container for the chart, allows zoom/pan handled by D3 */
        #chart-container {
            width: 100%;
            flex-grow: 1; /* Allow container to grow and fill remaining space */
            overflow: hidden; /* Hide default scrollbars */
            padding: 0;
            box-sizing: border-box;
        }

        /* SVG element styling */
        svg {
            display: block; /* Remove extra space below svg */
            width: 100%; /* Fill container width */
            height: 100%; /* Fill container height */
        }

        /* Styling for the node card (using foreignObject) */
        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 中央寄せに変更 */
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 border */
            border-radius: 12px; /* Tailwind rounded-xl */
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            width: 120px; /* Fixed width for the card */
            height: 100%; /* Make card fill foreignObject height */
            box-sizing: border-box; /* Include padding and border in width/height */
            text-align: center;
            transition: background-color 0.3s ease, border-color 0.3s ease; /* Smooth transition for highlight */
        }

        .node-card a {
             /* リンク自体は維持するが、flexboxのレイアウトには使わない */
             text-decoration: none;
             color: inherit;
             display: block; /* flex item ではなく block 要素にする */
             width: 100%;
             height: 100%; /* カード全体をリンク可能にする */
             display: flex; /* 子要素を中央寄せするためにflexboxを使う */
             flex-direction: column;
             align-items: center;
             justify-content: center;
        }


        .node-name {
            font-size: 11px;
            text-align: center;
            font-weight: 600;
            line-height: 1.3;
            white-space: normal;
            word-break: break-word;
            max-width: 100%;
            /* 画像や他の要素を削除したので、マージンは不要か調整 */
            margin: 0;
        }

        /* Remove styles for elements that are being removed */
        /*
        .node-image, .node-placeholder, .node-introducer, .node-reason {
            display: none;
        }
        */


        .link {
            fill: none;
            stroke: #94a3b8; /* Tailwind slate-400 */
            stroke-width: 1.5px;
        }

        /* Styling for highlighting the searched node */
        .node-highlight .node-card {
            background-color: #fef3c7; /* Tailwind amber-100 for background highlight */
            border-color: #f59e0b; /* Tailwind amber-500 for border emphasis */
            /* box-shadow: 0 0 10px rgba(245, 158, 11, 0.7); */ /* Optional: stronger shadow */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>フットサルメンバー紹介ツリー（D3.js版）</h1>

    <div id="search-container">
        <div class="search-input-wrapper">
            <input type="text" id="search-input" placeholder="メンバーの名前で検索" autocomplete="off" />
            <div id="suggestions-container"></div>
        </div>
        <button id="search-button">検索</button>
    </div>

    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // Define the path to your JSON data file
        const JSON_FILE_PATH = 'tree_data.json'; // このファイルパスが正しいことを確認してください

        let allNodesData = []; // Store flattened node data for searching and suggestions
        let currentZoomBehavior = null; // Store the current zoom behavior instance
        let nodeElementsMap = new Map(); // Store node D3 selections keyed by ID
        let hierarchyNodeMap = new Map(); // Store D3 hierarchy nodes keyed by ID

        // Variables to store overall SVG dimensions, calculated once after all subtrees are processed
        let finalSvgWidth = 0;
        let finalSvgHeight = 0;
        let mainG; // Main group for all chart elements

        // Helper function to convert Hiragana to Katakana for search matching
        function hiraToKata(str) {
            if (!str) return "";
            return str.replace(/[\u3041-\u3096]/g, function(match) {
                const chr = match.charCodeAt(0) + 0x60;
                return String.fromCharCode(chr);
            });
        }

        // Wait for the DOM to be fully loaded
        window.addEventListener("DOMContentLoaded", () => {
            const searchInput = document.getElementById("search-input");
            const searchButton = document.getElementById("search-button");
            const suggestionsContainer = document.getElementById("suggestions-container");
            const svg = d3.select("#tree-svg");
            const chartContainer = d3.select("#chart-container");
            mainG = svg.append("g"); // Define mainG here to be accessible globally within this scope

            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>データの形式が正しくありません。</p>";
                        return;
                    }
                    allNodesData = jsonData;

                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "その他");
                    const margin = {top: 40, right: 20, bottom: 40, left: 20};
                    const nodeWidth = 120;
                    // ノードの高さを調整（画像や他の要素を削除したため）
                    const nodeHeight = 60; // Adjusted height for name only
                    const verticalSpacing = 60; // Increased for more space
                    const horizontalSpacing = 30; // Increased for more space

                    let tempMaxTreeWidth = 0; // Max width among individual trees
                    let currentYOffset = margin.top;
                    let allRootsLayouts = []; // Store layout info for second pass

                    // First pass: Calculate layout for each tree and determine overall dimensions
                    groupedData.forEach((groupData, reason) => {
                        const rootNodesData = groupData.filter(d => d.introducerPageId === null);
                        rootNodesData.forEach(rootData => {
                            const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));
                            // nodeSizeのy軸をnodeHeight + verticalSpacingに設定
                            const treeLayout = d3.tree().nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);
                            treeLayout(root);

                            let x0 = Infinity, x1 = -Infinity;
                            root.each(d => {
                                // レイアウト計算後のノード座標を基準に幅を計算
                                if (d.x < x0) x0 = d.x;
                                if (d.x > x1) x1 = d.x;
                            });
                            // ツリーの実際の幅は x の最小値から最大値までの範囲 + ノードの幅
                            const treeWidth = (x1 - x0) + nodeWidth;
                            if (treeWidth > tempMaxTreeWidth) {
                                tempMaxTreeWidth = treeWidth;
                            }
                            // ツリーの実際の高さは y の最小値から最大値までの範囲 + ノードの高さ
                            // D3 tree layoutのy座標は深さに基づいて増える
                            const treeHeight = root.height * (nodeHeight + verticalSpacing) + nodeHeight;


                            allRootsLayouts.push({ root, reason, x0, x1, treeWidth, treeHeight, startY: currentYOffset });
                            currentYOffset += treeHeight + margin.bottom; // Add height of the tree and margin for the next one
                        });
                    });

                    // Total width is max individual tree width plus left/right margins
                    finalSvgWidth = tempMaxTreeWidth + margin.left + margin.right;
                    // Total height is the final accumulated Y offset (includes top margin of first tree
                    // and bottom margin after the last tree)
                    finalSvgHeight = currentYOffset;


                    // Second pass: Draw the trees now that we have final max width and total height
                    allRootsLayouts.forEach(({ root, reason, x0, x1, treeWidth, startY }) => {
                         // Calculate offset to center this subtree horizontally within the total SVG width
                         // (x0 + x1) / 2 is the center of the node x coordinates
                         // Subtract this center from the center of the finalSvgWidth to find the translation needed
                        const offsetX = (finalSvgWidth / 2) - ((x0 + x1) / 2);

                        const subtreeG = mainG.append("g")
                            .attr("transform", `translate(${offsetX}, ${startY})`);

                        // Add a title for the subtree group if needed (optional)
                        // subtreeG.append("text")
                        //     .attr("x", 0) // Position relative to subtreeG
                        //     .attr("y", -margin.top / 2) // Position above the root
                        //     .attr("text-anchor", "middle")
                        //     .text(reason);


                        subtreeG.append("g")
                            .attr("fill", "none")
                            .attr("stroke-linejoin", "round")
                            .attr("stroke-width", 1.5)
                            .selectAll("path")
                            .data(root.links())
                            .join("path")
                            .attr("class", "link")
                            .attr("d", d3.linkVertical()
                                .x(d => d.x)
                                .y(d => d.y)
                            );

                        const node = subtreeG.append("g")
                            .selectAll("g")
                            .data(root.descendants())
                            .join("g")
                            .attr("transform", d => `translate(${d.x},${d.y})`)
                            .attr("id", d => `node-${d.data.id}`); // Assign an ID to the node group

                        node.each(function(d) {
                            nodeElementsMap.set(d.data.id, d3.select(this));
                        });

                        const nodeForeignObject = node.append("foreignObject")
                            .attr("x", -(nodeWidth / 2))
                            .attr("y", -(nodeHeight / 2))
                            .attr("width", nodeWidth)
                            .attr("height", nodeHeight);

                        const nodeCard = nodeForeignObject.append("xhtml:div")
                            .attr("class", "node-card");

                        const linkWrapper = nodeCard.append("a")
                            .attr("href", d => d.data.page_url || "#")
                            .attr("target", "_blank");

                         // メンバー名のみを表示
                        linkWrapper.append("div")
                             .attr("class", "node-name")
                             .text(d => d.data.name);

                        // 画像、紹介者、理由の表示コードは削除しました

                    });


                    svg.attr("viewBox", `0 0 ${finalSvgWidth} ${finalSvgHeight}`)
                       .attr("preserveAspectRatio", "xMidYMid meet");


                    currentZoomBehavior = d3.zoom()
                        .scaleExtent([0.05, 3]) // Wider zoom range
                        .on("zoom", zoomed);

                    svg.call(currentZoomBehavior);

                    function zoomed(event) {
                        mainG.attr("transform", event.transform);
                    }
                    
                    // Initial fit and center
                    setTimeout(() => {
                        const containerNode = chartContainer.node();
                        if (!containerNode) return;
                        const containerWidth = containerNode.clientWidth;
                        const containerHeight = containerNode.clientHeight;

                        if (finalSvgWidth === 0 || finalSvgHeight === 0) {
                            console.warn("SVG dimensions are zero. Cannot perform initial fit.");
                            return; // Avoid division by zero or invalid transform
                        }

                        // Calculate scale to fit the entire content bounding box (finalSvgWidth, finalSvgHeight)
                        const scaleX = containerWidth / finalSvgWidth;
                        const scaleY = containerHeight / finalSvgHeight;
                        const initialScale = Math.min(scaleX, scaleY, 1.0); // Cap at 1.0

                         // Calculate translation to center the scaled content within the container
                         // The target center of the SVG content (in SVG's initial coordinates) is (finalSvgWidth / 2, finalSvgHeight / 2)
                         // We want this point to be at (containerWidth / 2, containerHeight / 2) after scaling and translating
                         // target_screen = transform(target_svg)
                         // (containerWidth / 2, containerHeight / 2) = transform(finalSvgWidth / 2, finalSvgHeight / 2)
                         // (containerWidth / 2, containerHeight / 2) = scale * (finalSvgWidth / 2) + translateX, scale * (finalSvgHeight / 2) + translateY
                         // translateX = containerWidth / 2 - scale * (finalSvgWidth / 2)
                         // translateY = containerHeight / 2 - scale * (finalSvgHeight / 2)

                        const initialTranslateX = containerWidth / 2 - initialScale * (finalSvgWidth / 2);
                        const initialTranslateY = containerHeight / 2 - initialScale * (finalSvgHeight / 2);


                        const initialTransform = d3.zoomIdentity
                            .translate(initialTranslateX, initialTranslateY)
                            .scale(initialScale);
                        
                        svg.transition().duration(750).call(currentZoomBehavior.transform, initialTransform);
                    }, 100); // Small delay to ensure container dimensions are stable


                    // --- Search Input Suggestions ---
                    searchInput.addEventListener("input", function() {
                        // Convert input term to lowercased katakana for matching
                        const term = hiraToKata(this.value.trim().toLowerCase());
                        suggestionsContainer.innerHTML = ""; // Clear previous suggestions
                        if (!term) {
                            suggestionsContainer.style.display = "none";
                            return;
                        }

                        // Filter nodes whose name (converted to katakana) includes the term
                        const matches = allNodesData.filter(d => d.name && hiraToKata(d.name).toLowerCase().includes(term)).slice(0, 10); // Limit suggestions

                        if (matches.length > 0) {
                            matches.forEach(match => {
                                const item = document.createElement("div");
                                item.classList.add("suggestion-item");
                                item.textContent = match.name; // Display original name in suggestion
                                item.addEventListener("click", () => {
                                    searchInput.value = match.name; // Put original name back in input
                                    suggestionsContainer.style.display = "none";
                                    searchButton.click(); // Trigger search
                                });
                                suggestionsContainer.appendChild(item);
                            });
                            suggestionsContainer.style.display = "block";
                        } else {
                            suggestionsContainer.style.display = "none";
                        }
                    });

                    // Hide suggestions when clicking outside
                    document.addEventListener("click", function(event) {
                        if (!searchInput.contains(event.target) && !suggestionsContainer.contains(event.target)) {
                            suggestionsContainer.style.display = "none";
                        }
                    });


                    // --- Search Functionality ---
                    searchButton.addEventListener("click", () => {
                        const searchTerm = searchInput.value.trim();
                        suggestionsContainer.style.display = "none"; // Hide suggestions

                        // Remove previous highlights
                        mainG.selectAll(".node-highlight").classed("node-highlight", false);

                        if (!searchTerm) return;

                         // Convert search term to lowercased katakana for exact matching
                        const searchKata = hiraToKata(searchTerm).toLowerCase();

                         // Find node where name (converted to katakana) exactly matches search term
                        const foundNodeData = allNodesData.find(d => d.name && hiraToKata(d.name).toLowerCase() === searchKata);

                        if (foundNodeData) {
                            const foundHierarchyNode = hierarchyNodeMap.get(foundNodeData.id);
                            const foundNodeElement = nodeElementsMap.get(foundNodeData.id);

                            if (foundHierarchyNode && foundNodeElement) {
                                foundNodeElement.classed("node-highlight", true);

                                const containerNode = chartContainer.node();
                                if (!containerNode) return;
                                const containerWidth = containerNode.clientWidth;
                                const containerHeight = containerNode.clientHeight;

                                // Get the transform applied to the subtree G this node belongs to
                                let subtreeTransform = { x: 0, y: 0 };
                                let parent = foundNodeElement.node().parentNode; // This is the <g> for nodes
                                parent = parent.parentNode; // This should be the subtreeG

                                const subtreeTransformString = d3.select(parent).attr("transform");
                                if (subtreeTransformString) {
                                     const match = subtreeTransformString.match(/translate\(([^,]+),([^)]+)\)/);
                                     if (match) {
                                         subtreeTransform.x = parseFloat(match[1]);
                                         subtreeTransform.y = parseFloat(match[2]);
                                     }
                                }

                                // Calculate the absolute position of the found node within the mainG's
                                // unscaled coordinate system. It's the node's layout position plus the subtree's translation.
                                const targetMainGX = foundHierarchyNode.x + subtreeTransform.x;
                                const targetMainGY = foundHierarchyNode.y + subtreeTransform.y;

                                // Get the current transform of the SVG (applied to mainG by zoom)
                                const currentTransform = d3.zoomTransform(svg.node());

                                // Calculate the desired transform to center the target node
                                // The target screen position is the center of the container (containerWidth/2, containerHeight/2)
                                // The target SVG position (within mainG's initial coordinates) is (targetMainGX, targetMainGY)
                                // We want transform * (targetMainGX, targetMainGY) = (containerWidth/2, containerHeight/2)
                                // transform = translate * scale
                                // translate(tx, ty) * scale(k) * (targetMainGX, targetMainGY) = (containerWidth/2, containerHeight/2)
                                // k * targetMainGX + tx = containerWidth/2 => tx = containerWidth/2 - k * targetMainGX
                                // k * targetMainGY + ty = containerHeight/2 => ty = containerHeight/2 - k * targetMainGY

                                // We'll keep the current scale and only pan to the node
                                const targetScale = currentTransform.k; // Keep current zoom level
                                const targetTranslateX = containerWidth / 2 - targetScale * targetMainGX;
                                const targetTranslateY = containerHeight / 2 - targetScale * targetMainGY;

                                const newTransform = d3.zoomIdentity
                                     .translate(targetTranslateX, targetTranslateY)
                                     .scale(targetScale);

                                svg.transition().duration(750).call(currentZoomBehavior.transform, newTransform);

                            } else {
                                console.warn("Could not find hierarchy node or element for data ID:", foundNodeData.id);
                                alert("検索されたメンバーのノードが見つかりませんでした。");
                            }
                        } else {
                            alert("「" + searchTerm + "」という名前のメンバーは見つかりませんでした。");
                        }
                    });

                    searchInput.addEventListener("keypress", function(event) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            searchButton.click();
                        }
                    });

                })
                .catch(error => {
                    console.error('Error processing data:', error);
                    document.getElementById("chart-container").innerHTML = `<p>データの処理中にエラーが発生しました: ${error.message}</p>`;
                });
        });
    </script>
</body>
</html>
