<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆï¼‰</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* blue-700 */
            color: white;
        }

        #chart-container {
            width: 100%;
            /* Allow vertical overflow for scrolling if tree is very tall */
            overflow-x: auto;
            overflow-y: auto; /* Changed to auto to allow vertical scrolling */
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem;
            box-sizing: border-box; /* Include padding in width */
            /* touch-action: pan-x pan-y; /* Removed to allow default click behavior */
        }

        svg {
            display: block; /* Remove extra space below svg */
            /* margin: 0 auto; /* Removed auto margin for better control with zoom/pan */
            /* Set initial width and height dynamically */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 12px; /* rounded-xl */
            padding: 8px; /* Increased padding slightly */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 120px; /* Increased width slightly */
            box-sizing: border-box; /* Include padding and border in width */
            text-align: center;
        }

        /* Add styles for the link wrapper inside the node card */
        .node-card a {
            text-decoration: none; /* Remove underline from links */
            color: inherit; /* Inherit text color */
            display: flex; /* Use flexbox for link content */
            flex-direction: column; /* Stack content vertically within link */
            align-items: center; /* Center content horizontally within link */
            width: 100%; /* Make link fill the card width */
            /* Prevent touch actions on links specifically if needed, but general SVG handling is better */
            /* touch-action: manipulation; */
        }


        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 6px; /* Increased space below image */
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

         .node-placeholder {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #d1d5db; /* bg-gray-300 */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4b5563; /* text-gray-600 */
            font-weight: bold; /* font-bold */
            font-size: 1rem; /* Increased font size */
            margin-bottom: 6px; /* Increased space below placeholder */
         }


        .node-name {
            font-size: 11px; /* Increased font size slightly */
            text-align: center;
            font-weight: 600; /* Increased font weight */
            line-height: 1.3; /* Adjusted line height */
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            max-width: 100%; /* Ensure name fits within card */
        }

         .node-introducer, .node-reason {
            font-size: 9px; /* Smaller font for details */
            color: #555;
            text-align: center;
            line-height: 1.2;
            white-space: normal;
            word-break: break-word;
            max-width: 100%;
            margin-top: 2px; /* Space above introducer/reason */
         }


        .link {
            fill: none;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 1.5px; /* Increased line thickness */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆï¼‰</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // ã“ã“ã‚’GitHubã®Rawtherapee URLã«å¤‰æ›´ã—ã¦ãã ã•ã„
        const JSON_FILE_PATH = 'tree_data.json'; // Replace with your actual GitHub Raw URL

        window.addEventListener("DOMContentLoaded", () => {
            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
                        return;
                    }

                    // Group data by introduction_reason for separate trees
                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "ãã®ä»–");

                    const svg = d3.select("#tree-svg");
                    const chartContainer = d3.select("#chart-container");
                    const margin = {top: 40, right: 20, bottom: 40, left: 20}; // Adjusted margins
                    const nodeWidth = 120; // Matches .node-card width
                    const nodeHeight = 80; // Approximate height of .node-card content
                    const verticalSpacing = 50; // Space between parent and child levels
                    const horizontalSpacing = 20; // Minimum space between sibling nodes

                    let currentYOffset = margin.top;
                    let maxSvgWidth = 0;
                    let totalSvgHeight = 0; // Track total height needed

                    // Create a main group to hold all group subtrees - This group will be zoomed/panned
                    const mainG = svg.append("g");

                    // Add a background rectangle to the main group to make panning easier
                    mainG.append("rect")
                        .attr("width", "100%") // Initial width, will be updated
                        .attr("height", "100%") // Initial height, will be updated
                        .attr("fill", "transparent"); // Make it invisible

                    groupedData.forEach((groupData, reason) => {
                        const rootNodesData = groupData.filter(d => d.introducerPageId === null);

                        rootNodesData.forEach(rootData => {
                            const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));

                            const treeLayout = d3.tree()
                                .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);

                            treeLayout(root);

                            let x0 = Infinity, x1 = -Infinity;
                            root.each(d => {
                                if (d.x < x0) x0 = d.x;
                                if (d.x > x1) x1 = d.x;
                            });

                            const subtreeWidth = x1 - x0 + nodeWidth + horizontalSpacing;
                            if (subtreeWidth > maxSvgWidth) {
                                maxSvgWidth = subtreeWidth;
                            }

                            const offsetX = (maxSvgWidth / 2) - ((x1 + x0) / 2);

                            // Create a group for the current subtree within the main group
                            const subtreeG = mainG.append("g")
                                .attr("transform", `translate(${margin.left + offsetX}, ${currentYOffset})`);

                            // Draw links
                            subtreeG.append("g")
                                .attr("fill", "none")
                                .attr("stroke-linejoin", "round")
                                .attr("stroke-width", 1.5)
                                .selectAll("path")
                                .data(root.links())
                                .join("path")
                                .attr("class", "link")
                                .attr("d", d3.linkVertical()
                                    .x(d => d.x)
                                    .y(d => d.y)
                                );

                            // Draw nodes
                            const node = subtreeG.append("g")
                                .selectAll("g")
                                .data(root.descendants())
                                .join("g")
                                .attr("transform", d => `translate(${d.x},${d.y})`);

                            const nodeForeignObject = node.append("foreignObject")
                                .attr("x", -(nodeWidth / 2))
                                .attr("y", -(nodeHeight / 2))
                                .attr("width", nodeWidth)
                                .attr("height", nodeHeight);

                            const nodeCard = nodeForeignObject.append("xhtml:div")
                                .attr("class", "node-card");

                            const linkWrapper = nodeCard.append("a")
                                .attr("href", d => d.data.page_url || "#")
                                .attr("target", "_blank")
                                .style("text-decoration", "none")
                                .style("color", "inherit")
                                .style("display", "flex")
                                .style("flex-direction", "column")
                                .style("align-items", "center")
                                .style("width", "100%");


                            linkWrapper.each(function(d) {
                                const container = d3.select(this);
                                if (d.data.image) {
                                    container.append("img")
                                        .attr("class", "node-image")
                                        .attr("src", d.data.image)
                                        .attr("alt", "photo");
                                } else {
                                    container.append("div")
                                        .attr("class", "node-placeholder")
                                        .text(d.data.name ? d.data.name.charAt(0) : '?');
                                }
                            });

                            const textContent = linkWrapper.append("div");
                            textContent.append("div")
                                .attr("class", "node-name")
                                .text(d => d.data.name);

                            textContent.each(function(d) {
                                const container = d3.select(this);
                                if (d.data.introducer_name) {
                                    container.append("div")
                                        .attr("class", "node-introducer")
                                        .text(`ç´¹ä»‹è€…: ${d.data.introducer_name}`);
                                }
                            });

                            // Add space for the next subtree
                            const subtreeHeight = root.height * (nodeHeight + verticalSpacing);
                            currentYOffset += subtreeHeight + margin.bottom + verticalSpacing;
                            totalSvgHeight += subtreeHeight + margin.bottom + verticalSpacing;

                        }); // End rootNodesData.forEach
                    }); // End groupedData.forEach

                    // Adjust SVG width and height based on content
                    const finalSvgWidth = maxSvgWidth + margin.left + margin.right;
                    const finalSvgHeight = totalSvgHeight + margin.top + margin.bottom; // Use totalSvgHeight
                    svg.attr("width", finalSvgWidth);
                    svg.attr("height", finalSvgHeight);

                    // Update background rect size
                    mainG.select("rect")
                        .attr("width", finalSvgWidth)
                        .attr("height", finalSvgHeight);


                    // ğŸŒŸ ä¸­å¤®ã«è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ 
                    const containerElement = document.getElementById("chart-container");
                    // Use a slight delay to ensure rendering is complete before scrolling
                     setTimeout(() => {
                         // Scroll to center horizontally
                         containerElement.scrollLeft = (finalSvgWidth - containerElement.clientWidth) / 2;
                         // Scroll to top vertically (or a little bit down if needed)
                         containerElement.scrollTop = 0; // Or a small offset like margin.top
                     }, 100);


                    // --- Pinch-to-Zoom and Pan Functionality ---
                    let initialPinchDistance = 0;
                    let currentScale = 1;
                    let lastTranslateX = 0;
                    let lastTranslateY = 0;
                    let isPanning = false;
                    let lastTouchX = 0;
                    let lastTouchY = 0;
                    let initialTouchX = 0; // Added to track initial touch position
                    let initialTouchY = 0; // Added to track initial touch position
                    const tapThreshold = 5; // Pixels: how far a touch can move and still be considered a tap

                    // Get the bounding box of the SVG for coordinate calculations
                    const svgRect = svg.node().getBoundingClientRect();

                    svg.on("touchstart", (event) => {
                        if (event.touches.length === 2) {
                            // Pinch start
                            initialPinchDistance = getPinchDistance(event.touches);
                            isPanning = false; // Not panning when pinching
                            // Prevent default only for pinch start to avoid scrolling interference
                            event.preventDefault();
                        } else if (event.touches.length === 1) {
                            // Pan or Tap start
                            isPanning = false; // Assume not panning initially
                            lastTouchX = event.touches[0].clientX;
                            lastTouchY = event.touches[0].clientY;
                            initialTouchX = lastTouchX; // Record initial position
                            initialTouchY = lastTouchY; // Record initial position

                            // Get current transform for smooth panning start
                            const transform = mainG.attr("transform");
                            if (transform) {
                                const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                                if (translateMatch) {
                                    lastTranslateX = parseFloat(translateMatch[1]);
                                    lastTranslateY = parseFloat(translateMatch[2]);
                                } else {
                                     lastTranslateX = 0;
                                     lastTranslateY = 0;
                                }
                            } else {
                                lastTranslateX = 0;
                                lastTranslateY = 0;
                            }
                            // Do NOT preventDefault here to allow potential link clicks
                        }
                    });

                    svg.on("touchmove", (event) => {
                        if (event.touches.length === 2) {
                            // Pinch move
                            event.preventDefault(); // Prevent default touch behavior like scrolling/zooming

                            const currentPinchDistance = getPinchDistance(event.touches);
                            if (initialPinchDistance === 0) {
                                initialPinchDistance = currentPinchDistance; // Handle case where touchstart missed
                                return;
                            }

                            // Calculate scale change
                            const scaleChange = currentPinchDistance / initialPinchDistance;
                            currentScale *= scaleChange;

                            // Optional: Clamp scale to a reasonable range (e.g., 0.5 to 3)
                            currentScale = Math.max(0.5, Math.min(currentScale, 3));

                            // Apply scale transformation to the main group
                            // We need to maintain the current translation as well
                            mainG.attr("transform", `translate(${lastTranslateX}, ${lastTranslateY}) scale(${currentScale})`);

                            initialPinchDistance = currentPinchDistance; // Update initial distance for next move event

                        } else if (event.touches.length === 1) {
                            // Pan move
                            const touch = event.touches[0];
                            const deltaX = touch.clientX - lastTouchX;
                            const deltaY = touch.clientY - lastTouchY;

                            // Check if touch has moved beyond tap threshold
                            const moveDistance = Math.sqrt(
                                Math.pow(touch.clientX - initialTouchX, 2) +
                                Math.pow(touch.clientY - initialTouchY, 2)
                            );

                            if (moveDistance > tapThreshold) {
                                isPanning = true; // It's a pan, not a tap
                                event.preventDefault(); // Prevent default behavior (like scrolling)
                            }

                            if (isPanning) {
                                lastTranslateX += deltaX;
                                lastTranslateY += deltaY;

                                // Apply pan transformation to the main group, maintaining current scale
                                mainG.attr("transform", `translate(${lastTranslateX}, ${lastTranslateY}) scale(${currentScale})`);

                                lastTouchX = touch.clientX;
                                lastTouchY = touch.clientY;
                            }
                        }
                    });

                    svg.on("touchend", (event) => {
                        // Reset state when touches end
                        initialPinchDistance = 0;
                        // isPanning state is used in touchmove to decide preventDefault

                        // If it was a pan, prevent default to stop potential click after drag
                        if (isPanning) {
                             // Check if there are still touches left from other fingers (for multi-touch)
                             if (event.touches.length === 0) {
                                // Only prevent default if all touches have ended and it was a pan
                                // This is tricky, as preventDefault in touchend can prevent clicks.
                                // A better approach is to preventDefault only in touchmove if it's a drag.
                                // Let's rely on the touchmove logic to set isPanning and preventDefault there.
                             }
                        }
                         isPanning = false; // Reset for the next interaction
                         // Do NOT preventDefault here unconditionally, let default click happen if it was a tap
                    });

                     svg.on("touchcancel", (event) => {
                        // Handle cases where touch is interrupted (e.g., call incoming)
                        initialPinchDistance = 0;
                        isPanning = false;
                     });


                    // Helper function to calculate distance between two touch points
                    function getPinchDistance(touches) {
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        return Math.sqrt(dx * dx + dy * dy);
                    }

                    // --- End Pinch-to-Zoom and Pan Functionality ---


                })
                .catch(error => {
                    console.error('Error fetching JSON data:', error);
                    document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚GitHubã®Rawtherapee URLãŒæ­£ã—ã„ã‹ã€ã¾ãŸã¯CORSã®å•é¡ŒãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>";
                });
        });

        // Optional: Redraw on window resize (more complex with D3 layout)
        // For simplicity, we'll skip full redraw on resize for this example.
        // A robust solution would recalculate layout and redraw SVG on resize.

    </script>
</body>
</html>
