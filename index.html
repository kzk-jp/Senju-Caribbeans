<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>フットサルメンバー紹介ツリー（D3.js版）</title>
    <style>
        /* Basic body styling */
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            color: #333; /* Dark gray text */
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            height: 100vh; /* Full viewport height */
        }

        /* Header styling */
        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* Tailwind blue-700 */
            color: white;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        /* Search container styling */
        #search-container {
            text-align: center;
            padding: 10px;
            background-color: #e5e7eb; /* Tailwind gray-200 */
            border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 */
            flex-shrink: 0; /* Prevent search bar from shrinking */
            position: relative; /* For suggestion box positioning */
        }

        /* Wrapper for input and suggestions for better layout control */
        .search-input-wrapper {
            position: relative;
            display: inline-block;
            width: 280px; /* Adjust width as needed */
            vertical-align: middle; /* Align with button */
        }

        #search-container input[type="text"] {
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 1rem;
            width: 100%; /* Fill the wrapper */
            box-sizing: border-box;
        }

        #search-container button {
            padding: 8px 15px;
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
            margin-left: 5px; /* Space between input wrapper and button */
            vertical-align: middle; /* Align with input wrapper */
        }

        #search-container button:hover {
            background-color: #2563eb; /* Tailwind blue-700 */
        }

        /* Suggestions container styling */
        #suggestions-container {
            position: absolute;
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-top: none;
            z-index: 1000;
            max-height: 150px;
            overflow-y: auto;
            width: 100%; /* Match wrapper width */
            left: 0;
            top: 100%; /* Position it right below the input */
            box-sizing: border-box;
            display: none; /* Initially hidden */
            text-align: left; /* Align text to the left for readability */
        }

        .suggestion-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #333;
        }

        .suggestion-item:hover {
            background-color: #e0e0e0; /* Lighter gray for hover */
        }


        /* Container for the chart, allows zoom/pan handled by D3 */
        #chart-container {
            width: 100%;
            flex-grow: 1; /* Allow container to grow and fill remaining space */
            overflow: hidden; /* Hide default scrollbars */
            padding: 0;
            box-sizing: border-box;
        }

        /* SVG element styling */
        svg {
            display: block; /* Remove extra space below svg */
            width: 100%; /* Fill container width */
            height: 100%; /* Fill container height */
        }

        /* Styling for the node card (using foreignObject) */
        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 border */
            border-radius: 12px; /* Tailwind rounded-xl */
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            width: 120px; /* Fixed width for the card */
            height: 100%; /* Make card fill foreignObject height */
            box-sizing: border-box; /* Include padding and border in width/height */
            text-align: center;
            transition: background-color 0.3s ease, border-color 0.3s ease; /* Smooth transition for highlight */
        }

        .node-card a {
            text-decoration: none;
            color: inherit;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 6px;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

        .node-placeholder {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4b5563;
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .node-name {
            font-size: 11px;
            text-align: center;
            font-weight: 600;
            line-height: 1.3;
            white-space: normal;
            word-break: break-word;
            max-width: 100%;
        }

        .node-introducer, .node-reason {
            font-size: 9px;
            color: #555;
            text-align: center;
            line-height: 1.2;
            white-space: normal;
            word-break: break-word;
            max-width: 100%;
            margin-top: 2px;
        }

        .link {
            fill: none;
            stroke: #94a3b8; /* Tailwind slate-400 */
            stroke-width: 1.5px;
        }

        /* Styling for highlighting the searched node */
        .node-highlight .node-card {
            background-color: #fef3c7; /* Tailwind amber-100 for background highlight */
            border-color: #f59e0b; /* Tailwind amber-500 for border emphasis */
            /* box-shadow: 0 0 10px rgba(245, 158, 11, 0.7); */ /* Optional: stronger shadow */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>フットサルメンバー紹介ツリー（D3.js版）</h1>

    <div id="search-container">
        <div class="search-input-wrapper">
            <input type="text" id="search-input" placeholder="メンバーの名前で検索" autocomplete="off" />
            <div id="suggestions-container"></div>
        </div>
        <button id="search-button">検索</button>
    </div>

    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // Define the path to your JSON data file
        const JSON_FILE_PATH = 'tree_data.json'; // このファイルパスが正しいことを確認してください

        let allNodesData = []; // Store flattened node data for searching and suggestions
        let currentZoomBehavior = null; // Store the current zoom behavior instance
        let nodeElementsMap = new Map(); // Store node D3 selections keyed by ID
        let hierarchyNodeMap = new Map(); // Store D3 hierarchy nodes keyed by ID

        // Variables to store overall SVG dimensions, calculated once after all subtrees are processed
        let finalSvgWidth = 0;
        let finalSvgHeight = 0;
        let mainG; // Main group for all chart elements

        // Wait for the DOM to be fully loaded
        window.addEventListener("DOMContentLoaded", () => {
            const searchInput = document.getElementById("search-input");
            const searchButton = document.getElementById("search-button");
            const suggestionsContainer = document.getElementById("suggestions-container");
            const svg = d3.select("#tree-svg");
            const chartContainer = d3.select("#chart-container");
            mainG = svg.append("g"); // Define mainG here to be accessible globally within this scope

            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>データの形式が正しくありません。</p>";
                        return;
                    }
                    allNodesData = jsonData;

                    // Populate suggestions initially if needed, or just prepare for input handling
                    // (Suggestions will be built on input)

                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "その他");
                    const margin = {top: 40, right: 20, bottom: 40, left: 20};
                    const nodeWidth = 120;
                    const nodeHeight = 90; // Adjusted slightly for potentially more text
                    const verticalSpacing = 60; // Increased for more space
                    const horizontalSpacing = 30; // Increased for more space

                    let tempMaxTreeWidth = 0; // Max width among individual trees
                    let currentYOffset = margin.top;
                    let allRootsLayouts = []; // Store layout info for second pass

                    // First pass: Calculate layout for each tree and determine overall dimensions
                    groupedData.forEach((groupData, reason) => {
                        const rootNodesData = groupData.filter(d => d.introducerPageId === null);
                        rootNodesData.forEach(rootData => {
                            const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));
                            const treeLayout = d3.tree().nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);
                            treeLayout(root);

                            let x0 = Infinity, x1 = -Infinity;
                            root.each(d => {
                                if (d.x < x0) x0 = d.x;
                                if (d.x > x1) x1 = d.x;
                            });
                            const treeWidth = (x1 - x0) + nodeWidth; // Width of this specific tree
                            if (treeWidth > tempMaxTreeWidth) {
                                tempMaxTreeWidth = treeWidth;
                            }
                            const treeHeight = root.height * (nodeHeight + verticalSpacing) + nodeHeight;

                            allRootsLayouts.push({ root, reason, x0, x1, treeWidth, treeHeight, startY: currentYOffset });
                            currentYOffset += treeHeight + margin.bottom; // Spacing for next tree group

                            // Populate hierarchyNodeMap
                            root.descendants().forEach(dNode => {
                                if (dNode.data && dNode.data.id) {
                                    hierarchyNodeMap.set(dNode.data.id, dNode);
                                }
                            });
                        });
                    });

                    finalSvgWidth = tempMaxTreeWidth + margin.left + margin.right;
                    finalSvgHeight = currentYOffset - margin.bottom + margin.top; // Total height based on last Y offset

                    // Second pass: Draw the trees now that we have final max width
                    allRootsLayouts.forEach(({ root, reason, x0, x1, treeWidth, startY }) => {
                        const offsetX = (finalSvgWidth / 2) - ((x1 + x0 + nodeWidth) / 2) ; // Centering calculation

                        const subtreeG = mainG.append("g")
                            .attr("transform", `translate(${offsetX}, ${startY})`);

                        subtreeG.append("g")
                            .attr("fill", "none")
                            .attr("stroke-linejoin", "round")
                            .attr("stroke-width", 1.5)
                            .selectAll("path")
                            .data(root.links())
                            .join("path")
                            .attr("class", "link")
                            .attr("d", d3.linkVertical()
                                .x(d => d.x)
                                .y(d => d.y)
                            );

                        const node = subtreeG.append("g")
                            .selectAll("g")
                            .data(root.descendants())
                            .join("g")
                            .attr("transform", d => `translate(${d.x},${d.y})`)
                            .attr("id", d => `node-${d.data.id}`); // Assign an ID to the node group

                        node.each(function(d) {
                            nodeElementsMap.set(d.data.id, d3.select(this));
                        });

                        const nodeForeignObject = node.append("foreignObject")
                            .attr("x", -(nodeWidth / 2))
                            .attr("y", -(nodeHeight / 2))
                            .attr("width", nodeWidth)
                            .attr("height", nodeHeight);

                        const nodeCard = nodeForeignObject.append("xhtml:div")
                            .attr("class", "node-card");

                        const linkWrapper = nodeCard.append("a")
                            .attr("href", d => d.data.page_url || "#")
                            .attr("target", "_blank");

                        linkWrapper.each(function(d) {
                            const container = d3.select(this);
                            if (d.data.image) {
                                container.append("img")
                                    .attr("class", "node-image")
                                    .attr("src", d.data.image)
                                    .attr("alt", d.data.name + " photo");
                            } else {
                                container.append("div")
                                    .attr("class", "node-placeholder")
                                    .text(d.data.name ? d.data.name.charAt(0).toUpperCase() : '?');
                            }
                        });

                        const textContent = linkWrapper.append("div");
                        textContent.append("div")
                            .attr("class", "node-name")
                            .text(d => d.data.name);

                        textContent.each(function(d) {
                            const container = d3.select(this);
                            if (d.data.introducer_name) {
                                container.append("div")
                                    .attr("class", "node-introducer")
                                    .text(`紹介者: ${d.data.introducer_name}`);
                            }
                            if (d.data.introduction_reason && d.data.introduction_reason !== "その他") {
                                 container.append("div")
                                    .attr("class", "node-reason")
                                    .text(`理由: ${d.data.introduction_reason}`);
                            }
                        });
                    });


                    svg.attr("viewBox", `0 0 ${finalSvgWidth} ${finalSvgHeight}`)
                       .attr("preserveAspectRatio", "xMidYMid meet");


                    currentZoomBehavior = d3.zoom()
                        .scaleExtent([0.05, 3]) // Wider zoom range
                        .on("zoom", zoomed);

                    svg.call(currentZoomBehavior);

                    function zoomed(event) {
                        mainG.attr("transform", event.transform);
                    }
                    
                    // Initial fit and center
                    setTimeout(() => {
                        const containerNode = chartContainer.node();
                        if (!containerNode) return;
                        const containerWidth = containerNode.clientWidth;
                        const containerHeight = containerNode.clientHeight;

                        if (finalSvgWidth === 0 || finalSvgHeight === 0) return; // Avoid division by zero

                        const scaleX = containerWidth / finalSvgWidth;
                        const scaleY = containerHeight / finalSvgHeight;
                        const initialScale = Math.min(scaleX, scaleY, 1.0); // Cap at 1.0

                        const initialTranslateX = (containerWidth - finalSvgWidth * initialScale) / 2;
                        const initialTranslateY = (containerHeight - finalSvgHeight * initialScale) / 2;
                        
                        const initialTransform = d3.zoomIdentity
                            .translate(initialTranslateX, initialTranslateY)
                            .scale(initialScale);
                        
                        svg.transition().duration(750).call(currentZoomBehavior.transform, initialTransform);
                    }, 100);


                    // --- Search Input Suggestions ---
                    searchInput.addEventListener("input", function() {
                        const term = this.value.trim().toLowerCase();
                        suggestionsContainer.innerHTML = ""; // Clear previous suggestions
                        if (!term) {
                            suggestionsContainer.style.display = "none";
                            return;
                        }

                        const matches = allNodesData.filter(d => d.name && d.name.toLowerCase().includes(term)).slice(0, 10); // Limit suggestions

                        if (matches.length > 0) {
                            matches.forEach(match => {
                                const item = document.createElement("div");
                                item.classList.add("suggestion-item");
                                item.textContent = match.name;
                                item.addEventListener("click", () => {
                                    searchInput.value = match.name;
                                    suggestionsContainer.style.display = "none";
                                    searchButton.click(); // Trigger search
                                });
                                suggestionsContainer.appendChild(item);
                            });
                            suggestionsContainer.style.display = "block";
                        } else {
                            suggestionsContainer.style.display = "none";
                        }
                    });

                    // Hide suggestions when clicking outside
                    document.addEventListener("click", function(event) {
                        if (!searchInput.contains(event.target) && !suggestionsContainer.contains(event.target)) {
                            suggestionsContainer.style.display = "none";
                        }
                    });


                    // --- Search Functionality ---
                    searchButton.addEventListener("click", () => {
                        const searchTerm = searchInput.value.trim();
                        suggestionsContainer.style.display = "none"; // Hide suggestions

                        // Remove previous highlights
                        mainG.selectAll(".node-highlight").classed("node-highlight", false);

                        if (!searchTerm) return;

                        const foundNodeData = allNodesData.find(d => d.name && d.name.toLowerCase() === searchTerm.toLowerCase()); // Exact match for search, suggestions are includes based

                        if (foundNodeData) {
                            const foundHierarchyNode = hierarchyNodeMap.get(foundNodeData.id);
                            const foundNodeElement = nodeElementsMap.get(foundNodeData.id);

                            if (foundHierarchyNode && foundNodeElement) {
                                foundNodeElement.classed("node-highlight", true);

                                const containerNode = chartContainer.node();
                                if (!containerNode) return;
                                const containerWidth = containerNode.clientWidth;
                                const containerHeight = containerNode.clientHeight;

                                // Get the absolute position of the node within the mainG's unscaled coordinate system
                                let targetMainGX = foundHierarchyNode.x;
                                let targetMainGY = foundHierarchyNode.y;

                                let parent = foundNodeElement.node().parentNode; // This is the <g> for nodes
                                parent = parent.parentNode; // This should be the subtreeG
                                
                                const subtreeTransformString = d3.select(parent).attr("transform");
                                if (subtreeTransformString) {
                                    const match = subtreeTransformString.match(/translate\(([^,]+),([^)]+)\)/);
                                    if (match) {
                                        targetMainGX += parseFloat(match[1]);
                                        targetMainGY += parseFloat(match[2]);
                                    }
                                }
                                
                                // Calculate scale to fit the entire tree
                                const scaleX = containerWidth / finalSvgWidth;
                                const scaleY = containerHeight / finalSvgHeight;
                                const fitAllScale = Math.min(scaleX, scaleY, 1.0); // Cap at 1.0, ensure it fits

                                const newTransform = d3.zoomIdentity
                                    .translate(containerWidth / 2, containerHeight / 2)
                                    .scale(fitAllScale)
                                    .translate(-targetMainGX, -targetMainGY);

                                svg.transition().duration(750).call(currentZoomBehavior.transform, newTransform);

                            } else {
                                console.warn("Could not find hierarchy node or element for data:", foundNodeData);
                                alert("検索されたメンバーのノードが見つかりませんでした。");
                            }
                        } else {
                            alert("「" + searchTerm + "」という名前のメンバーは見つかりませんでした。");
                        }
                    });

                    searchInput.addEventListener("keypress", function(event) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            searchButton.click();
                        }
                    });

                })
                .catch(error => {
                    console.error('Error processing data:', error);
                    document.getElementById("chart-container").innerHTML = `<p>データの処理中にエラーが発生しました: ${error.message}</p>`;
                });
        });
    </script>
</body>
</html>
