<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>フットサルメンバー紹介ツリー</title>
    <style>
        /* Basic body styling */
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            color: #333; /* Dark gray text */
        }

        /* Header container styling */
        /* ヘッダーとリンクボタンを配置するためのコンテナ */
        .header-container {
            display: flex; /* Flexboxを使用して子要素を横並びにする */
            justify-content: center; /* タイトルを中央に配置 */
            align-items: center; /* 子要素を垂直方向の中央に配置 */
            padding: 0.5rem 1rem; /* 上下のパディングを半分に */
            margin: 0;
            background: #2563eb; /* Tailwind blue-700 */
            color: white;
            height: 35px; /* ヘッダーの高さを調整 */
            position: sticky; /* ヘッダーを固定 */
            top: 0; /* 画面上部に固定 */
            z-index: 1000; /* 他の要素より前面に表示 */
            box-sizing: border-box; /* パディングを含めて高さ計算 */
        }

        /* Header title styling */
        .header-container h1 {
            text-align: center; /* タイトルを中央寄せに */
            padding: 0; /* コンテナでパディングを設定したのでここでは0 */
            margin: 0;
            font-size: 1.1rem; /* フォントサイズを調整 */
            color: white; /* 親要素で設定済みだが明示的に */
            white-space: nowrap; /* タイトルが改行されないようにする */
        }

        /* Search container styling */
        #search-container {
            padding: 4px 1rem; /* 上下のパディングを調整し、左右はヘッダーと合わせる */
            background-color: #e5e7eb; /* Tailwind gray-200 */
            border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 0; /* 角丸を解除 */
            box-shadow: none; /* 影を解除 */
            width: auto; /* 幅の固定を解除 */
            height: 30px; /* 検索バーの高さを調整 */
            display: flex; /* Flexboxを使用して子要素を配置 */
            justify-content: space-between; /* リンクボタンを左、検索機能を右に配置 */
            align-items: center; /* 垂直方向の中央に */
            position: sticky; /* 検索バーを固定 */
            top: 35px; /* ヘッダーの高さ分下に配置 */
            z-index: 999; /* ヘッダーよりは下だが、ツリーよりは前面に表示 */
            box-sizing: border-box; /* パディングを含めて高さ計算 */
            flex-wrap: nowrap; /* 子要素の折り返しを防ぐ */
        }

        /* Group for list and reset buttons */
        .button-group {
            display: flex;
            gap: 8px; /* ボタン間のマージン */
            align-items: center;
            flex-shrink: 0; /* 縮小しない */
        }

        /* Search link button styling (formerly .header-link) */
        .search-link, .reset-button {
            display: inline-block; /* ボタンとして表示 */
            padding: 4px 8px; /* ボタンのパディングを調整 */
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
            text-decoration: none; /* 下線を削除 */
            border-radius: 20px; /* 角丸を大きく */
            font-size: 0.7rem; /* フォントサイズを調整 */
            transition: background-color 0.2s ease;
            flex-shrink: 0; /* 縮小しない */
            border: none; /* ボタンの枠線を削除 */
            cursor: pointer; /* カーソルをポインターに */
            box-sizing: border-box; /* パディングとボーダーを幅に含める */
            text-align: center; /* テキストを中央寄せにする */
        }

        .search-link:hover, .reset-button:hover {
            background-color: #2563eb; /* Tailwind blue-700 */
        }

        /* Container for search input and button */
        .search-controls {
            display: flex;
            align-items: center;
            margin-left: auto; /* 右に寄せる */
            flex-shrink: 1; /* 縮小を許可 */
            min-width: 0; /* flexアイテムの最小幅を設定 */
            gap: 5px; /* inputとbuttonの間の隙間をflexboxのgapで管理 */
        }

        #search-container input[type="text"] {
            padding: 4px 6px; /* 入力フィールドのpaddingも小さく */
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem; /* フォントサイズを調整 */
            width: 100%; /* 親のinput-containerの幅に合わせる */
            min-width: 80px; /* 最小幅を設定して小さくなりすぎないようにする */
            box-sizing: border-box;
            height: 25px; /* 入力フィールドの高さを調整 */
        }

        #search-container button {
            padding: 4px 8px; /* ボタンのpaddingも小さく */
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
            border: none;
            border-radius: 44px; /* ボタンの角を丸く */
            cursor: pointer;
            font-size: 0.9rem; /* フォントサイズを調整 */
            transition: background-color 0.2s ease;
            height: 25px; /* ボタンの高さを調整 */
            display: flex; /* ボタン内のテキストを中央に */
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* 縮小しない */
        }

        #search-container button:hover {
            background-color: #2563eb; /* Tailwind blue-700 */
        }

        /* Search suggestions dropdown */
        #suggestions-list {
            position: absolute;
            left: 50%; /* 親要素の中央に */
            transform: translateX(-50%); /* 要素自体の幅の半分だけ左に移動 */
            top: 100%; /* 検索入力ボックスの直下に配置 */
            width: calc(100%); /* 入力フィールドの幅に合わせる (gap分はinput-containerで調整) */
            max-width: 180px; /* 最大幅を設定 */
            max-height: 120px; /* Limit height and add scroll */
            overflow-y: auto;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden by default */
            z-index: 10; /* ツリーより前面に表示 */
            font-size: 0.8rem; /* フォントサイズを調整 */
        }

         /* input要素を基準にするための調整 */
        #search-container .input-container {
            position: relative; /* このコンテナ内で絶対配置 */
            display: flex; /* flexboxに変更 */
            flex-grow: 1; /* 親要素の幅に合わせて拡張 */
            max-width: 180px; /* 検索ボックスの最大幅を制限 */
            min-width: 80px; /* 最小幅を設定 */
        }


        #suggestions-list li {
            padding: 6px 8px; /* パディングを調整 */
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem; /* フォントサイズを調整 */
        }

        #suggestions-list li:last-child {
            border-bottom: none;
        }

        #suggestions-list li:hover {
            background-color: #f3f4f6;
        }


        /* Container for the chart, allows scrolling */
        #chart-container {
            width: 100%;
            /* ヘッダー(35px)と検索バー(30px)の合計高さを65pxに調整 */
            height: calc(100vh - 65px);
            overflow: hidden; /* Hide default scrollbars, D3 zoom handles pan */
            padding-top: 0; /* パディングを解除 */
            box-sizing: border-box;
        }

        /* SVG element styling */
        svg {
            display: block; /* Remove extra space below svg */
            width: 100%;
            height: 100%;
        }

        /* Styling for the node card (using foreignObject) */
        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* Tailwind gray-300 border */
            border-radius: 12px; /* Tailwind rounded-xl */
            padding: 8px; /* Original padding */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            width: 120px; /* Original width for the card */
            box-sizing: border-box; /* Include padding and border in width */
            text-align: center;
        }

        /* Styling for the link wrapper inside the node card */
        .node-card a {
            text-decoration: none; /* Remove underline from links */
            color: inherit; /* Inherit text color */
            display: flex; /* Use flexbox for link content */
            flex-direction: column; /* Stack content vertically within link */
            align-items: center; /* Center content horizontally within link */
            width: 100%; /* Make link fill the card width */
        }

        /* Styling for the node image */
        .node-image {
            width: 50px; /* Original image size */
            height: 50px; /* Original image size */
            border-radius: 50%; /* Circular image */
            object-fit: cover; /* Crop image to fit */
            margin-bottom: 6px; /* Original space below image */
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2); /* Subtle shadow */
        }

        /* Styling for the placeholder when no image is available */
        .node-placeholder {
            width: 50px; /* Original placeholder size */
            height: 50px; /* Original placeholder size */
            border-radius: 50%; /* Circular placeholder */
            background-color: #d1d5db; /* Tailwind gray-300 */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4b5563; /* Tailwind gray-600 */
            font-weight: bold;
            font-size: 1rem; /* Original font size */
            margin-bottom: 6px; /* Original space below placeholder */
        }

        /* Styling for the node name */
        .node-name {
            font-size: 11px; /* Original font size */
            text-align: center;
            font-weight: 600; /* Semi-bold */
            line-height: 1.3; /* Adjusted line height */
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            max-width: 100%; /* Ensure name fits within card */
        }

        /* Styling for introducer and reason text */
        .node-introducer, .node-reason {
            font-size: 9px; /* Original smaller font for details */
            color: #555;
            text-align: center;
            line-height: 1.2;
            white-space: normal;
            word-break: break-word;
            max-width: 100%;
            margin-top: 2px; /* Original space above introducer/reason */
        }

        /* Styling for the links between nodes */
        .link {
            fill: none;
            stroke: #94a3b8; /* Tailwind slate-400 */
            stroke-width: 1.5px; /* Increased line thickness */
        }

        /* Styling for highlighting the searched node */
        .node-highlight .node-card {
            border-color: #f59e0b; /* Tailwind amber-500 */
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.6); /* Amber shadow */
            background-color: #fcd34d; /* Tailwind amber-300 - Highlight background color */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <div class="header-container">
        <h1>フットサルメンバー紹介ツリー</h1>
    </div>

    <div id="search-container">
        <div class="button-group">
            <a href="https://phase-laundry-290.notion.site/1eead9abbc8680bdbbf2db393fccb974?v=1eead9abbc8681cd81db000cb443821c" class="search-link" target="_blank">リスト表示</a>
            <button id="reset-button" class="reset-button">リセット</button>
        </div>
        <div class="search-controls">
            <div class="input-container">
                <input type="text" id="search-input" placeholder="名前で検索" autocomplete="off" />
                <ul id="suggestions-list"></ul>
            </div>
            <button id="search-button">検索</button>
        </div>
    </div>

    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // Define the path to your JSON data file
        // IMPORTANT: Replace with your actual GitHub Raw URL or local path
        const JSON_FILE_PATH = 'tree_data.json'; // JSONファイルのパスを適宜変更してください

        let allNodesData = []; // Store flattened node data for searching
        let nodeHierarchyMap = new Map(); // Store hierarchy nodes keyed by data ID
        let currentZoomBehavior = null; // Store the current zoom behavior
        let svgElement = null; // Reference to the SVG DOM element
        let mainGElement = null; // Reference to the main group DOM element
        let chartContainerElement = null; // Reference to the chart container DOM element
        let nodeElements = new Map(); // Store D3 selection of node elements by data ID

        // Function to convert Hiragana to Katakana
        function hiraToKata(str) {
            return str.replace(/[\u3041-\u3096]/g, function(match) {
                const chr = match.charCodeAt(0) + 0x60;
                return String.fromCharCode(chr);
            });
        }

        // Function to zoom and pan to a specific transform
        function zoomToTransform(transform) {
             svg.transition().duration(750).call(currentZoomBehavior.transform, transform);
        }


        // Wait for the DOM to be fully loaded
        window.addEventListener("DOMContentLoaded", () => {
            // Fetch the JSON data
            fetch(JSON_FILE_PATH)
                .then(response => {
                    // Check if the response was successful
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    // Parse the JSON data
                    return response.json();
                })
                .then(jsonData => {
                    // Validate the data format
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>データの形式が正しくありません。</p>";
                        return;
                    }

                    allNodesData = jsonData; // Store the fetched data

                    // Group data by introduction_reason to potentially draw separate trees
                    // If introduction_reason is null or undefined, group under "その他" (Other)
                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "その他");

                    // Select the SVG element and its container
                    const svg = d3.select("#tree-svg");
                    svgElement = svg.node(); // Store reference to the DOM element
                    const chartContainer = d3.select("#chart-container");
                    chartContainerElement = chartContainer.node(); // Store reference to the DOM element
                    const containerWidth = chartContainerElement.clientWidth;
                    const containerHeight = chartContainerElement.clientHeight;


                    // Define margins and node dimensions
                    const margin = {top: 40, right: 20, bottom: 40, left: 20}; // Original margins
                    const nodeWidth = 120; // Original width for the card
                    const nodeHeight = 80; // Original approximate height of .node-card content
                    const verticalSpacing = 50; // Original space between parent and child levels
                    const horizontalSpacing = 20; // Original minimum space between sibling nodes

                    let currentYOffset = margin.top; // Vertical offset for placing subtrees
                    let maxSvgWidth = 0; // Track maximum width needed for all subtrees
                    let totalSvgHeight = 0; // Track total height needed for all subtrees


                    // Create a main group to hold all group subtrees - This group will be zoomed/panne
                    const mainG = svg.append("g");
                    mainGElement = mainG.node(); // Store reference to the DOM element

                    // Store all hierarchy nodes to calculate the overall bounds later
                    const allHierarchyNodes = [];


                    // Iterate through each group (based on introduction_reason)
                    groupedData.forEach((groupData, reason) => {
                        // Find the root nodes for this group (nodes with no introducer)
                        const rootNodesData = groupData.filter(d => d.introducerPageId === null);

                        // For each root node, draw a separate tree
                        rootNodesData.forEach(rootData => {
                            // Create a D3 hierarchy from the root data
                            const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));

                            // Define the tree layout
                            const treeLayout = d3.tree()
                                // nodeSize sets the fixed dimensions for each node cell in the layout
                                .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]); // Original node size

                            // Apply the tree layout to the hierarchy
                            treeLayout(root);

                            // Calculate the horizontal extent of the current subtree
                            let x0 = Infinity, x1 = -Infinity;
                            root.each(d => {
                                if (d.x < x0) x0 = d.x;
                                if (d.x > x1) x1 = d.x;
                            });

                            // Calculate the width of the current subtree
                            const subtreeWidth = x1 - x0 + nodeWidth + horizontalSpacing;
                            // Update maxSvgWidth if the current subtree is wider
                            if (subtreeWidth > maxSvgWidth) {
                                maxSvgWidth = subtreeWidth;
                            }

                            // Calculate the horizontal offset needed to center the subtree
                            const offsetX = (maxSvgWidth / 2) - ((x1 + x0) / 2);

                            // Create a group for the current subtree within the main group
                            const subtreeG = mainG.append("g")
                                .attr("transform", `translate(${margin.left + offsetX}, ${currentYOffset})`);

                            // Draw links (paths) between nodes
                            subtreeG.append("g")
                                .attr("fill", "none")
                                .attr("stroke-linejoin", "round")
                                .attr("stroke-width", 1.5)
                                .selectAll("path")
                                .data(root.links()) // Get link data from the hierarchy
                                .join("path")
                                .attr("class", "link")
                                .attr("d", d3.linkVertical() // Use vertical links
                                    .x(d => d.x) // X coordinate of the node
                                    .y(d => d.y) // Y coordinate of the node
                                );

                            // Draw nodes (groups containing foreignObject for HTML content)
                            const node = subtreeG.append("g")
                                .selectAll("g")
                                .data(root.descendants()) // Get all nodes from the hierarchy
                                .join("g")
                                .attr("transform", d => `translate(${d.x},${d.y})`); // Position the node group

                            // Store the hierarchy node object keyed by its data ID
                            node.each(function(d) {
                                nodeHierarchyMap.set(d.data.id, d);
                                allHierarchyNodes.push(d); // Add to the list of all hierarchy nodes
                            });

                            // Store the D3 selection of the node element by data ID
                            node.each(function(d) {
                                nodeElements.set(d.data.id, d3.select(this));
                            });


                            // Append foreignObject to each node group to embed HTML
                            const nodeForeignObject = node.append("foreignObject")
                                .attr("x", -(nodeWidth / 2)) // Center the foreignObject horizontally
                                .attr("y", -(nodeHeight / 2)) // Center the foreignObject vertically
                                .attr("width", nodeWidth)
                                .attr("height", nodeHeight);

                            // Append the HTML div (.node-card) inside the foreignObject
                            const nodeCard = nodeForeignObject.append("xhtml:div")
                                .attr("class", "node-card");

                            // Append an anchor tag (link) inside the card
                            const linkWrapper = nodeCard.append("a")
                                .attr("href", d => d.data.page_url || "#") // Link to page_url or '#' if none
                                .attr("target", "_blank") // Open link in a new tab
                                // Apply necessary styles to the anchor tag to make it behave like a container
                                .style("text-decoration", "none")
                                .style("color", "inherit")
                                .style("display", "flex")
                                .style("flex-direction", "column")
                                .style("align-items", "center")
                                .style("width", "100%");

                            // Add image or placeholder to the link wrapper
                            linkWrapper.each(function(d) {
                                const container = d3.select(this);
                                if (d.data.image) {
                                    // If image URL exists, add an image element
                                    container.append("img")
                                        .attr("class", "node-image")
                                        .attr("src", d.data.image)
                                        .attr("alt", "photo");
                                } else {
                                    // If no image, add a placeholder div with the first letter of the name
                                    container.append("div")
                                        .attr("class", "node-placeholder")
                                        .text(d.data.name ? d.data.name.charAt(0) : '?');
                                }
                            });

                            // Add text content (name, introducer, reason) below the image/placeholder
                            const textContent = linkWrapper.append("div"); // Container for text elements
                            textContent.append("div")
                                .attr("class", "node-name")
                                .text(d => d.data.name); // Display the member's name

                            // Add introducer name if it exists
                            textContent.each(function(d) {
                                const container = d3.select(this);
                                if (d.data.introducer_name) {
                                    container.append("div")
                                        .attr("class", "node-introducer")
                                        .text(`紹介者: ${d.data.introducer_name}`);
                                }
                                // Add introduction reason if it exists and is not the default "その他"
                                if (d.data.introduction_reason && d.data.introduction_reason !== "その他") {
                                     container.append("div")
                                        .attr("class", "node-reason")
                                        .text(`理由: ${d.data.introduction_reason}`);
                                }
                            });


                            // Calculate the height of the current subtree
                            const subtreeHeight = root.height * (nodeHeight + verticalSpacing);
                            // Update the vertical offset for the next subtree
                            currentYOffset += subtreeHeight + margin.bottom + verticalSpacing;
                            // Add subtree height to the total height needed
                            totalSvgHeight += subtreeHeight + margin.bottom + verticalSpacing;

                        }); // End rootNodesData.forEach
                    }); // End groupedData.forEach

                    // Adjust SVG width and height based on the calculated maximum width and total height
                    // Set SVG dimensions large enough to contain all content initially
                    const finalSvgWidth = maxSvgWidth + margin.left + margin.right;
                    const finalSvgHeight = totalSvgHeight + margin.top + margin.bottom;
                    svg.attr("width", finalSvgWidth);
                    svg.attr("height", finalSvgHeight);


                    // --- D3 Zoom and Pan Functionality ---

                    // Create a zoom behavior
                    const zoom = d3.zoom()
                        // Set the extent of the zoomable area to the calculated SVG dimensions
                        // Allowing pan slightly outside the bounds
                        .extent([[0, 0], [finalSvgWidth, finalSvgHeight]])
                        // Restrict pan range to allow moving the view up to the original SVG size outside the original bounds
                        .translateExtent([
                            [-finalSvgWidth * 5, -finalSvgHeight * 5], // 元のSVGサイズ分だけ左上方向にパン可能 (範囲を5倍に拡大)
                            [finalSvgWidth * 5, finalSvgHeight * 5] // 元のSVGサイズ分だけ右下方向にパン可能 (範囲を5倍に拡大)
                        ])
                        // Set the zoom scale limits
                        .scaleExtent([0.1, 3]) // Allow zooming between 0.1x and 3x (最小スケールを0.1に変更)
                        // Define the function to call when zooming occurs
                        .on("zoom", zoomed);

                    // Apply the zoom behavior to the SVG element
                    svg.call(zoom);

                    // Store the zoom behavior for later use in the search function
                    currentZoomBehavior = zoom;

                    // Zoom event handler function
                    function zoomed(event) {
                        // Apply the transform from the zoom event to the main group
                        mainG.attr("transform", event.transform);
                    }

                     // --- Initial centering using zoom transform ---
                    // Initial load: Zoom to fit the entire tree
                    zoomToFitTree();
                    // --- End Initial centering ---


                    // --- Search Functionality ---
                    const searchInput = document.getElementById("search-input");
                    const searchButton = document.getElementById("search-button");
                    const suggestionsList = document.getElementById("suggestions-list");

                    // Function to perform the search and highlight
                    function performSearch(searchTerm) {
                         // Remove previous highlights
                         mainG.selectAll(".node-highlight").classed("node-highlight", false);

                         if (!searchTerm) {
                             // 検索語が空の場合はツリー全体表示のみ行う
                             zoomToFitTree();
                             return;
                         }

                        // Convert search term to Katakana for fuzzy matching
                        const searchTermKata = hiraToKata(searchTerm).toLowerCase();

                        // Find the node data that matches the search term (case-insensitive, using Katakana)
                        const foundNodeData = allNodesData.find(d => {
                            // Convert node name to Katakana for comparison if it's not already
                            const nodeName = d.name || "";
                            const nodeNameKata = hiraToKata(nodeName).toLowerCase();
                            return nodeNameKata.includes(searchTermKata);
                        });


                        if (foundNodeData) {
                            // Find the actual SVG group element for the found node
                            const foundNodeElement = nodeElements.get(foundNodeData.id);

                            if (foundNodeElement) {
                                // Add highlight to the found node's SVG group element
                                foundNodeElement.classed("node-highlight", true);

                                // 検索されたらツリー全体表示にズームアウト
                                zoomToFitTree();

                            } else {
                                console.warn("Could not find SVG element in map for data:", foundNodeData);
                                // カスタムメッセージボックスを表示するなどの代替手段を検討
                                displayMessage("検索されたメンバーのノード情報が見つかりませんでした。");
                                // 見つからなかった場合もツリー全体表示に戻す
                                zoomToFitTree();
                            }
                        } else {
                            // Member not found
                            displayMessage("「" + searchTerm + "」という名前のメンバーは見つかりませんでした。");
                            // 見つからなかった場合もツリー全体表示に戻す
                            zoomToFitTree();
                        }
                    }

                    // カスタムメッセージボックス表示関数 (alert()の代替)
                    function displayMessage(message) {
                        const messageBox = document.createElement('div');
                        messageBox.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background-color: #333;
                            color: white;
                            padding: 15px 25px;
                            border-radius: 8px;
                            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
                            z-index: 2000;
                            font-size: 1rem;
                            text-align: center;
                            opacity: 0;
                            transition: opacity 0.3s ease-in-out;
                        `;
                        messageBox.textContent = message;
                        document.body.appendChild(messageBox);

                        // フェードイン
                        setTimeout(() => {
                            messageBox.style.opacity = 1;
                        }, 10);

                        // 2秒後にフェードアウトして削除
                        setTimeout(() => {
                            messageBox.style.opacity = 0;
                            messageBox.addEventListener('transitionend', () => {
                                messageBox.remove();
                            }, { once: true });
                        }, 2000);
                    }


                    // Function to zoom to fit the entire tree within the container
                    function zoomToFitTree() {
                         // Get the bounding box of the main group (which contains the entire tree)
                         const mainGBounds = mainGElement.getBBox();

                         // Check if the bounding box is valid (width and height > 0)
                         if (mainGBounds.width <= 0 || mainGBounds.height <= 0) {
                             console.warn("Main group bounding box is invalid. Cannot zoom to fit tree.");
                             return;
                         }

                         const treeWidth = mainGBounds.width;
                         const treeHeight = mainGBounds.height;
                         const treeCenterX = mainGBounds.x + treeWidth / 2;
                         const treeCenterY = mainGBounds.y + treeHeight / 2;

                         const containerWidth = chartContainerElement.clientWidth;
                         const containerHeight = chartContainerElement.clientHeight;

                         // Calculate scale to fit the tree within the container, with some padding
                         const padding = 50; // Add some padding around the tree
                         const scaleX = (containerWidth - padding * 2) / treeWidth;
                         const scaleY = (containerHeight - padding * 2) / treeHeight;
                         
                         // Use the smaller scale to ensure the entire tree fits
                         let scale = Math.min(scaleX, scaleY);

                         // Clamp the scale within the zoom behavior's scale extent.
                         // Ensure it doesn't go below the minimum or above the maximum allowed by the zoom behavior.
                         scale = Math.max(currentZoomBehavior.scaleExtent()[0], Math.min(scale, currentZoomBehavior.scaleExtent()[1]));


                         // Calculate the translation to center the tree at the calculated scale
                         const translateX = containerWidth / 2 - treeCenterX * scale;
                         const translateY = containerHeight / 2 - treeCenterY * scale;

                         // Create the new transform
                         const newTransform = d3.zoomIdentity
                             .translate(translateX, translateY)
                             .scale(scale);

                         // Apply the transform
                         zoomToTransform(newTransform);
                     }


                    searchButton.addEventListener("click", () => {
                        const searchTerm = searchInput.value.trim();
                        performSearch(searchTerm);
                        suggestionsList.style.display = 'none'; // Hide suggestions after search
                    });

                    // Allow searching by pressing Enter in the input field
                    searchInput.addEventListener("keypress", (event) => {
                        if (event.key === "Enter") {
                            event.preventDefault(); // Prevent default form submission if any
                            const searchTerm = searchInput.value.trim();
                            performSearch(searchTerm);
                            suggestionsList.style.display = 'none'; // Hide suggestions after search
                        }
                    });

                    // --- Search Suggestion Functionality ---

                    searchInput.addEventListener("input", () => {
                        const searchTerm = searchInput.value.trim().toLowerCase();
                        suggestionsList.innerHTML = ''; // Clear previous suggestions

                        // 入力が空になったらハイライトをクリアし、ツリー全体表示に戻す
                        if (searchTerm.length === 0) {
                             mainG.selectAll(".node-highlight").classed("node-highlight", false);
                             suggestionsList.style.display = 'none';
                             zoomToFitTree(); // 入力クリアで全体表示
                             return;
                        }


                        if (searchTerm.length > 0) {
                            // Convert search term to Katakana for matching
                            const searchTermKata = hiraToKata(searchTerm);

                            // Filter nodes whose names contain the search term (case-insensitive, using Katakana)
                            const matchingNodes = allNodesData.filter(d => {
                                const nodeName = d.name || "";
                                const nodeNameKata = hiraToKata(nodeName).toLowerCase();
                                return nodeNameKata.includes(searchTermKata);
                            });

                            // Display suggestions
                            if (matchingNodes.length > 0) {
                                matchingNodes.forEach(node => {
                                    const li = document.createElement("li");
                                    li.textContent = node.name;
                                    li.addEventListener("click", () => {
                                        searchInput.value = node.name;
                                        performSearch(node.name);
                                        suggestionsList.style.display = 'none'; // Hide suggestions after selecting
                                    });
                                    suggestionsList.appendChild(li);
                                });
                                suggestionsList.style.display = 'block'; // Show suggestions list
                            } else {
                                suggestionsList.style.display = 'none'; // Hide if no matches
                            }
                        } else {
                            suggestionsList.style.display = 'none'; // Hide if input is empty
                        }
                    });

                    // Hide suggestions when clicking outside the input/list
                    document.addEventListener('click', (event) => {
                        const isClickInsideSearch = document.getElementById('search-container').contains(event.target);
                        if (!isClickInsideSearch) {
                            suggestionsList.style.display = 'none';
                        }
                    });

                    // --- Reset Button Functionality ---
                    const resetButton = document.getElementById("reset-button");
                    resetButton.addEventListener("click", () => {
                        // 検索ハイライトをクリア
                        mainG.selectAll(".node-highlight").classed("node-highlight", false);
                        // 検索入力フィールドをクリア
                        searchInput.value = '';
                        // サジェストリストを非表示
                        suggestionsList.style.display = 'none';

                        // ツリー全体表示にリセット
                        zoomToFitTree();
                    });


                    // --- Handle Window Resize ---
                    window.addEventListener('resize', () => {
                        // Recalculate container dimensions
                        const containerWidth = chartContainerElement.clientWidth;
                        const containerHeight = chartContainerElement.clientHeight;

                        // Re-apply zoom behavior with updated extent based on new container size
                        // This is important for translateExtent to work correctly after resize
                        const currentTransform = d3.zoomTransform(svgElement); // Get current transform
                        const zoom = d3.zoom()
                            .extent([[0, 0], [containerWidth, containerHeight]]) // Update extent to container size
                            .translateExtent([
                                [-finalSvgWidth * 5, -finalSvgHeight * 5], // Use original calculated tree size for pan limits (範囲を5倍に拡大)
                                [finalSvgWidth * 5, finalSvgHeight * 5] // 元のSVGサイズ分だけ右下方向にパン可能 (範囲を5倍に拡大)
                            ])
                            .scaleExtent([0.1, 3]) // 最小スケールを0.1に変更
                            .on("zoom", zoomed);

                        svg.call(zoom); // Apply the updated zoom behavior
                        currentZoomBehavior = zoom; // Store the updated behavior

                        // Recenter the tree after resize
                        zoomToFitTree();
                    });


                })
                .catch(error => {
                    // Handle any errors during the fetch operation
                    console.error("Error fetching or parsing JSON:", error);
                    document.getElementById("chart-container").innerHTML = "<p>データの読み込み中にエラーが発生しました。</p>";
                });
        });
    </script>
</body>
</html>
