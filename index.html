<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>カリビアンズ 加入チャート</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb;
            color: white;
        }

        #chart-container {
            width: 100%;
            overflow-x: auto; /* 横スクロールは維持 */
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem; /* コンテナ内のパディング */
            box-sizing: border-box;
        }

        svg {
            display: block;
            margin: auto;
            /* SVGの高さはJavaScriptで動的に設定 */
            background-color: #e0e0e0; /* ★診断用: SVG領域に薄い背景色★ */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 100px;
            box-sizing: border-box;
            text-align: center;
        }

        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 4px;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            background-color: #eee; /* Placeholder background */
        }

        .node-name {
            font-size: 10px;
            font-weight: 500;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90px;
            word-break: break-word;
        }

        .node-name a {
            text-decoration: none;
            color: #333;
        }

        .link {
            fill: none;
            stroke: #94a3b8;
            stroke-width: 1.2px;
        }
        /* 各ツリー間の余白 */
        .tree-group {
            margin-bottom: 40px; /* ツリーの下に余白を追加 */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>カリビアンズ 加入チャート</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
        <div id="loading-message" style="text-align: center; padding: 20px;">データを読み込み中...</div>
    </div>

    <script>
        // JSONファイルを相対パスで読み込む (GASスクリプトが出力するフラットなJSON)
        const JSON_FILE_PATH = 'tree_data.json'; // ★GASスクリプトのGITHUB_FILE_PATHと同じパスに置き換えてください★

        d3.json(JSON_FILE_PATH).then(function(flatData) { // フラットなデータとして読み込む
            const container = document.getElementById("chart-container");
            const svgElement = document.getElementById("tree-svg");

            console.log("Loaded flatData:", flatData);

            d3.select("#loading-message").remove();

            // JSONデータが配列であることを確認
            if (!Array.isArray(flatData) || flatData.length === 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">エラー: データの形式が不正です、またはデータがありません。</div>`);
                return;
            }

            // ★ここから修正: フラットなデータから階層構造を構築★
            const nodesById = new Map(flatData.map(node => [node.id, node])); // IDをキーとしたマップを作成
            const rootNodes = []; // ルートノードを格納する配列
            const allChildrenIds = new Set(); // 子として追加されたノードのIDを記録

            // 各ノードを処理し、親子関係を構築
            flatData.forEach(node => {
                // children配列を初期化 (D3.jsのhierarchyで使用するため)
                node.children = [];

                // introducerPageIdが存在し、かつそのIDを持つ親ノードがデータ内に存在する場合
                if (node.introducerPageId && nodesById.has(node.introducerPageId)) {
                    const parent = nodesById.get(node.introducerPageId);
                    // 親ノードに子として追加
                    if (!parent.children) {
                         parent.children = []; // 念のため初期化
                    }
                    parent.children.push(node);
                    allChildrenIds.add(node.id); // 子として追加されたノードのIDを記録
                }
                // introducerPageIdがない、または親ノードが見つからないノードは、
                // 後でallChildrenIdsに含まれていないものだけを真のルートとする
            });

            // 真のルートノードを特定 (introducerPageIdがない、または親が見つからず、かつ他のノードの子になっていないもの)
            flatData.forEach(node => {
                if (!node.introducerPageId || !nodesById.has(node.introducerPageId)) {
                     // introducerPageIdがない、または親が見つからないノード
                     if (!allChildrenIds.has(node.id)) {
                         // かつ、他のノードの子になっていない場合、真のルートとする
                         rootNodes.push(node);
                     } else {
                         // introducerPageIdがない、または親が見つからないが、なぜか他のノードの子になっている場合 (データ構造の異常)
                         console.warn(`Node ${node.name} (ID: ${node.id}) has no parent or parent not found, but is listed as a child. Skipping as root.`);
                     }
                }
            });


            console.log("Built hierarchy roots:", rootNodes);

            // 構築された階層構造のルートが空の場合
            if (rootNodes.length === 0 && flatData.length > 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">エラー: ルートノードが見つかりませんでした。データ構造を確認してください。</div>`);
                 return;
            } else if (rootNodes.length === 0 && flatData.length === 0) {
                 d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">データがありません。</div>`);
                 return;
            }


            // ノード間の間隔を調整 (縦型レイアウト向け)
            const dx = 250; // 横方向の間隔 (ノードカードの幅 + 余白)
            const dy = 110; // 縦方向の間隔 (ノードカードの高さ + 余白)

            const margin = { top: 40, right: 40, bottom: 40, left: 40 }; // marginの定義

            const svg = d3.select("#tree-svg");
            let totalSvgHeight = 0; // 全てのツリーを合わせたSVGの高さ

            // 各ルートノード（各独立したツリー）に対して描画処理
            rootNodes.forEach((rootData, index) => {
                 // childrenプロパティがない、または空の場合は単独ノードとして処理
                 if (!rootData.children || rootData.children.length === 0) {
                      console.log(`Processing single node: ${rootData.name}`);
                      const singleNodeG = svg.append("g")
                          // 単独ノードも横方向の中心に配置されるように調整
                          .attr("transform", `translate(${margin.left + (container.clientWidth / 2) - (100 / 2)}, ${totalSvgHeight + margin.top})`); // 横方向の中心, 縦方向は累計高さ

                      singleNodeG.append("foreignObject")
                          .attr("x", -50) // ノードの中心に合わせる (ノードカード幅100pxの半分)
                          .attr("y", -35) // ノードの中心に合わせる (ノードカード高さ80px程度の半分)
                          .attr("width", 100) // node-card width
                          .attr("height", 80) // node-card height (adjust as needed)
                          .append("xhtml:div")
                          .attr("class", "node-card")
                          .html(`
                              ${rootData.image ? `<img class="node-image" src="${rootData.image}" alt="${rootData.name} photo">` : '<div class="node-image" style="background-color: #ccc; display: flex; align-items: center; justify-content: center; font-size: 10px;">No Image</div>'}
                              <div class="node-name">
                                  ${rootData.page_url ? `<a href="${rootData.page_url}" target="_blank">${rootData.name}</a>` : rootData.name}
                              </div>
                          `);
                      singleNodeG.append("title").text(rootData.introduction_reason ? `紹介理由: ${rootData.introduction_reason}` : '');

                      totalSvgHeight += dy + margin.bottom; // 単独ノード分の高さ + 余白を加算
                      return; // 次のルートへ
                 }

                console.log(`Drawing tree for root: ${rootData.name}`); // ★診断用ログ★
                // D3.jsの階層データに変換
                const root = d3.hierarchy(rootData);

                const treeLayout = d3.tree().nodeSize([dy, dx]);
                treeLayout(root);

                // Calculate dimensions for the current subtree
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                root.each(d => {
                    minX = Math.min(minX, d.x);
                    maxX = Math.max(maxX, d.x);
                    minY = Math.min(minY, d.y);
                    maxY = Math.max(maxY, d.y);
                });

                const subtreeWidth = maxY - minY;
                const subtreeHeight = maxX - minX;

                // Add a group element for the current tree
                const g = svg.append("g")
                    .attr("class", "tree-group") // クラスを追加
                    // 各ツリーを縦に並べるように配置
                    // 横方向はツリーの幅を考慮して中央寄せ、縦方向は累計高さ
                    .attr("transform", `translate(${margin.left + (subtreeWidth / 2) - (minY)}, ${totalSvgHeight + margin.top})`); // 横方向の中心, 縦方向は累計高さ


                // Create the links for the current tree
                g.append("g")
                    .attr("fill", "none")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-linecap", "round")
                    .selectAll("path")
                    .data(root.links())
                    .join("path")
                    .attr("class", "link")
                    // 縦型レイアウト用のリンクパス
                    .attr("d", d3.linkVertical()
                        .x(d => d.x) // d.x が横方向の位置になる
                        .y(d => d.y)); // d.y が縦方向の位置になる


                // Create the nodes for the current tree
                const node = g.append("g")
                    .selectAll("g")
                    .data(root.descendants())
                    .join("g")
                    // 縦型レイアウト用のノード位置 (d.x が横, d.y が縦)
                    .attr("transform", d => {
                        console.log("Drawing node:", d.data.name, "at", d.x, d.y); // ★診断用ログ★
                        return `translate(${d.x},${d.y})`;
                    });

                // Add foreignObject for custom HTML content (the node card)
                node.append("foreignObject")
                    .attr("x", -50) // ノードの中心に合わせる (ノードカード幅100pxの半分)
                    .attr("y", -35) // ノードの中心に合わせる (ノードカード高さ80px程度の半分)
                    .attr("width", 100) // node-card width
                    .attr("height", 80) // node-card height (adjust as needed)
                    .append("xhtml:div")
                    .attr("class", "node-card")
                    .html(d => `
                        ${d.data.image ? `<img class="node-image" src="${d.data.image}" alt="${d.data.name} photo">` : '<div class="node-image" style="background-color: #ccc; display: flex; align-items: center; justify-content: center; font-size: 10px;">No Image</div>'}
                        <div class="node-name">
                            ${d.data.page_url ? `<a href="${d.data.page_url}" target="_blank">${d.data.name}</a>` : d.data.name}
                        </div>
                    `);

                 // Optional: Add tooltips for introduction reason
                 node.append("title")
                     .text(d => d.data.introduction_reason ? `紹介理由: ${d.data.introduction_reason}` : '');

                // 次のツリーのためにSVGの高さを更新
                totalSvgHeight += subtreeHeight + margin.bottom; // ツリーの高さ + ツリー間の余白

            });

            // 全てのツリーを描画した後でSVG全体の高さを設定
            svg.attr("height", totalSvgHeight + margin.top); // 最後のツリーの下にも余白を追加
             // SVGの幅をコンテナ幅に合わせるか、ツリーの最大幅に合わせるか検討
             // スマホ優先ならコンテナ幅に合わせつつ横スクロールが良いかも
             // svg.attr("width", container.clientWidth); // コンテナ幅に合わせる場合


            // 横方向のスクロール位置を調整 (縦型レイアウトでも横スクロールは必要)
            // containerとsvgElementは既に上で定義済み
            if (svgElement) {
              // ツリー全体の最大幅を計算してSVGの幅に設定する方が正確かもしれません
              let maxTreeWidth = 0;
               rootNodes.forEach(rootData => {
                   // childrenプロパティがない、または空の場合はスキップ（単独ノードは幅0として扱う）
                   if (!rootData.children || rootData.children.length === 0) {
                       return;
                   }
                   const root = d3.hierarchy(rootData);
                   const treeLayout = d3.tree().nodeSize([dy, dx]);
                   treeLayout(root);
                   let minY = Infinity, maxY = -Infinity;
                   root.each(d => {
                       minY = Math.min(minY, d.y);
                       maxY = Math.max(maxY, d.y);
                   });
                   maxTreeWidth = Math.max(maxTreeWidth, maxY - minY);
               });
               // 単独ノードの幅 (100px) と余白も考慮してSVGの最小幅を確保
               const minSvgWidth = 100 + margin.left + margin.right;
               const svgWidth = Math.max(maxTreeWidth + margin.left + margin.right, minSvgWidth);

               svg.attr("width", svgWidth);


              const containerCenter = container.clientWidth / 2;
              // 横方向の中心にスクロール
              container.scrollLeft = (svgWidth / 2) - containerCenter;
            }


        }).catch(function(error) {
            // JSONファイルの読み込みまたはパースに失敗した場合
            console.error("Error loading or parsing JSON:", error);
            d3.select("#loading-message").remove(); // ローディングメッセージを削除
            d3.select("#chart-container").html(`<div style="text-align: center; padding: 20px; color: red;">データの読み込みに失敗しました。<br>詳細: ${error.message || error}</div>`);
        });
    </script>
</body>
</html>
