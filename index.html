<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>フットサルメンバー紹介ツリー（D3.js版・最終スペース調整）</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* blue-700 */
            color: white;
        }

        #chart-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem;
            box-sizing: border-box; /* Include padding in width */
        }

        svg {
            display: block; /* Remove extra space below svg */
            margin: 0 auto; /* Center SVG if wider than container */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 12px; /* rounded-xl */
            padding: 8px; /* Increased padding slightly */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 120px; /* Matches .node-card width */
            box-sizing: border-box; /* Include padding and border in width */
            text-align: center;
        }

        .node-card a {
             text-decoration: none; /* Remove underline from links */
             color: inherit; /* Inherit text color */
             display: flex; /* Use flexbox for link content */
             flex-direction: column; /* Stack content vertically within link */
             align-items: center; /* Center content horizontally within link */
             width: 100%; /* Make link fill the card width */
        }


        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 6px; /* Increased space below image */
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

         .node-placeholder {
             width: 50px;
             height: 50px;
             border-radius: 50%;
             background-color: #d1d5db; /* bg-gray-300 */
             display: flex;
             align-items: center;
             justify-content: center;
             color: #4b5563; /* text-gray-600 */
             font-weight: bold; /* font-bold */
             font-size: 1rem; /* Increased font size */
             margin-bottom: 6px; /* Increased space below placeholder */
         }


        .node-name {
            font-size: 11px; /* Increased font size slightly */
            text-align: center;
            font-weight: 600; /* Increased font weight */
            line-height: 1.3; /* Adjusted line height */
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            max-width: 100%; /* Ensure name fits within card */
        }

         .node-introducer, .node-reason {
             font-size: 9px; /* Smaller font for details */
             color: #555;
             text-align: center;
             line-height: 1.2;
             white-space: normal;
             word-break: break-word;
             max-width: 100%;
             margin-top: 2px; /* Space above introducer/reason */
         }


        .link {
            fill: none;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 1.5px; /* Increased line thickness */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>フットサルメンバー紹介ツリー（D3.js版・最終スペース調整）</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // ここをGitHubのRawtherapee URLに変更してください
        const JSON_FILE_PATH = 'tree_data.json'; // Replace with your actual GitHub Raw URL

        window.addEventListener("DOMContentLoaded", () => {
            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>データの形式が正しくありません。</p>";
                        return;
                    }

                    // Group data by introduction_reason for separate trees
                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "その他");

                    const svg = d3.select("#tree-svg");
                    const chartContainer = d3.select("#chart-container");
                    const margin = {top: 40, right: 20, bottom: 40, left: 20}; // Adjusted margins
                    const nodeWidth = 120; // Matches .node-card width
                    const nodeHeight = 80; // Approximate height of .node-card content
                    const verticalSpacing = 80; // Increased space between parent and child levels
                    const horizontalSpacing = 30; // Increased minimum space between sibling nodes
                    const groupSpacing = 150; // Increased space between different groups (Adjust this value)

                    let currentYOffset = margin.top;
                    let maxSvgWidth = 0;

                    // Create a main group to hold all group subtrees
                    const mainG = svg.append("g");

                    // Sort groups by reason for consistent order (optional)
                    const sortedGroups = Array.from(groupedData).sort((a, b) => a[0].localeCompare(b[0]));


                    sortedGroups.forEach(([reason, groupData]) => {
                        // Find the root node(s) for this group (introducerPageId is null within this group's data)
                         const rootNodesData = groupData.filter(d => d.introducerPageId === null);

                         // Calculate the maximum height needed for this entire group
                         // We need to do this BEFORE drawing the group to know its total height
                         let groupMaxHeight = 0;
                         let groupCalculatedWidth = 0; // Also track group width to find overall max width

                         rootNodesData.forEach(rootData => {
                             // Build a temporary hierarchy to calculate layout and dimensions
                             const tempRoot = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));

                             const tempTreeLayout = d3.tree()
                                 .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);

                             tempTreeLayout(tempRoot);

                             // Calculate the extent of the subtree for positioning
                             let x0 = Infinity, x1 = -Infinity;
                             tempRoot.each(d => {
                                 if (d.x < x0) x0 = d.x;
                                 if (d.x > x1) x1 = d.x;
                             });

                             const subtreeWidth = x1 - x0 + nodeWidth + horizontalSpacing;
                             if (subtreeWidth > groupCalculatedWidth) {
                                 groupCalculatedWidth = subtreeWidth;
                             }

                             let maxDepth = 0;
                             tempRoot.each(d => {
                                 if (d.depth > maxDepth) maxDepth = d.depth;
                             });
                             // Calculate height including the node itself and spacing below it for its deepest descendant
                             // We need to consider the y-coordinate of the deepest node relative to the root of the subtree
                             let maxY = 0;
                             tempRoot.each(d => {
                                 if (d.y > maxY) maxY = d.y;
                             });
                             const subtreeCalculatedHeight = maxY + (nodeHeight / 2); // Add half node height for bottom clearance


                             if (subtreeCalculatedHeight > groupMaxHeight) {
                                 groupMaxHeight = subtreeCalculatedHeight;
                             }
                         }); // End temp rootNodesData.forEach

                         // Update the overall max SVG width based on this group's width
                         if (groupCalculatedWidth > maxSvgWidth) {
                             maxSvgWidth = groupCalculatedWidth;
                         }


                         // Now, create and draw the group at the correct currentYOffset
                         const groupG = mainG.append("g")
                             .attr("transform", `translate(0, ${currentYOffset})`); // Translate the entire group


                         // Add a text element for the group title
                         groupG.append("text")
                             .attr("x", margin.left) // Position title
                             .attr("y", -groupSpacing / 2) // Position above the group
                             .attr("dy", "0.35em")
                             .style("font-weight", "bold")
                             .text(reason);


                         // Draw each subtree within this groupG
                         rootNodesData.forEach(rootData => {
                             // Build the hierarchy for this root and its descendants (again, for drawing)
                             const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));

                             // Define the tree layout (same as for calculation)
                             const treeLayout = d3.tree()
                                 .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);

                             // Compute the layout
                             treeLayout(root);

                             // Calculate the extent of the subtree for horizontal centering within the group
                             let x0 = Infinity, x1 = -Infinity;
                             root.each(d => {
                                 if (d.x < x0) x0 = d.x;
                                 if (d.x > x1) x1 = d.x;
                             });

                             // Calculate the horizontal offset to center the subtree within the *group's* calculated width
                             const offsetX = (groupCalculatedWidth / 2) - ((x1 + x0) / 2);


                             // Create a group for the current subtree within the groupG
                             const subtreeG = groupG.append("g")
                                 .attr("transform", `translate(${margin.left + offsetX}, 0)`); // Apply horizontal offset within the group


                             // Draw links
                             subtreeG.append("g")
                                 .attr("fill", "none")
                                 .attr("stroke-linejoin", "round")
                                 .attr("stroke-width", 1.5) /* Increased line thickness */
                                 .selectAll("path")
                                 .data(root.links())
                                 .join("path")
                                 .attr("class", "link")
                                 .attr("d", d3.linkVertical()
                                     .x(d => d.x)
                                     .y(d => d.y)
                                 );

                             // Draw nodes
                             const node = subtreeG.append("g")
                                 .selectAll("g")
                                 .data(root.descendants())
                                 .join("g")
                                 .attr("transform", d => `translate(${d.x},${d.y})`);

                             // Append foreignObject for HTML content
                             const nodeCard = node.append("foreignObject")
                                 .attr("x", -(nodeWidth / 2)) // Center the foreignObject horizontally
                                 .attr("y", -(nodeHeight / 2)) // Center the foreignObject vertically (approx)
                                 .attr("width", nodeWidth)
                                 .attr("height", nodeHeight)
                                 .append("xhtml:div")
                                 .attr("class", "node-card");

                             // Add link wrapper if URL exists
                             const linkWrapper = nodeCard.append("a")
                                 .attr("href", d => d.data.url || "#") // Use 'url' field for link
                                 .attr("target", "_blank"); // Open in new tab

                             // Add image or placeholder
                             linkWrapper.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.image) {
                                     container.append("img")
                                         .attr("class", "node-image")
                                         .attr("src", d.data.image)
                                         .attr("alt", "photo");
                                 } else {
                                     container.append("div")
                                         .attr("class", "node-placeholder")
                                         .text(d.data.name ? d.data.name.charAt(0) : '?');
                                 }
                             });


                             // Add text content (name, introducer, reason)
                             const textContent = linkWrapper.append("div"); // Put text inside the link
                             textContent.append("div")
                                 .attr("class", "node-name")
                                 .text(d => d.data.name);

                             textContent.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.introducer_name) {
                                     container.append("div")
                                         .attr("class", "node-introducer")
                                         .text(`紹介者: ${d.data.introducer_name}`);
                                 }
                             });

                         }); // End drawing rootNodesData.forEach

                         // After processing and drawing all roots in a group,
                         // add the maximum height of the group to the currentYOffset for the next group,
                         // plus the group spacing.
                         currentYOffset += groupMaxHeight + groupSpacing;


                    }); // End groupedData.forEach

                    // Adjust SVG width and height based on content
                    svg.attr("width", maxSvgWidth + margin.left + margin.right);
                    svg.attr("height", currentYOffset); // Use the final currentYOffset


                    // 🌟 中央に自動スクロールする処理を追加
                    const containerElement = document.getElementById("chart-container");
                    // Use a slight delay to ensure rendering is complete before scrolling
                     setTimeout(() => {
                         containerElement.scrollLeft = (svg.attr("width") - containerElement.clientWidth) / 2;
                     }, 100);


                })
                .catch(error => {
                    console.error('Error fetching JSON data:', error);
                    document.getElementById("chart-container").innerHTML = "<p>データの読み込みに失敗しました。GitHubのRawtherapee URLが正しいか、またはCORSの問題がないか確認してください。</p>";
                });
        });

         // Optional: Redraw on window resize (more complex with D3 layout)
         // For simplicity, we'll skip full redraw on resize for this example.
         // A robust solution would recalculate layout and redraw SVG on resize.

    </script>
</body>
</html>
