<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆãƒ»ã‚°ãƒ«ãƒ¼ãƒ—é‡ãªã‚Šè§£æ¶ˆï¼‹ç®±ï¼‰</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* blue-700 */
            color: white;
        }

        #chart-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: auto; /* Allow vertical scrolling */
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem;
            box-sizing: border-box; /* Include padding in width */
        }

        svg {
            display: block; /* Remove extra space below svg */
            margin: 0 auto; /* Center SVG if wider than container */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 12px; /* rounded-xl */
            padding: 8px; /* Increased padding slightly */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 120px; /* Increased width slightly */
            box-sizing: border-box; /* Include padding and border in width */
            text-align: center;
        }

        .node-card a {
             text-decoration: none; /* Remove underline from links */
             color: inherit; /* Inherit text color */
             display: flex; /* Use flexbox for link content */
             flex-direction: column; /* Stack content vertically within link */
             align-items: center; /* Center content horizontally within link */
             width: 100%; /* Make link fill the card width */
        }


        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 6px; /* Increased space below image */
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

         .node-placeholder {
             width: 50px;
             height: 50px;
             border-radius: 50%;
             background-color: #d1d5db; /* bg-gray-300 */
             display: flex;
             align-items: center;
             justify-content: center;
             color: #4b5563; /* text-gray-600 */
             font-weight: bold; /* font-bold */
             font-size: 1rem; /* Increased font size */
             margin-bottom: 6px; /* Increased space below placeholder */
         }


        .node-name {
            font-size: 11px; /* Increased font size slightly */
            text-align: center;
            font-weight: 600; /* Increased font weight */
            line-height: 1.3; /* Adjusted line height */
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            max-width: 100%; /* Ensure name fits within card */
        }

         .node-introducer, .node-reason {
             font-size: 9px; /* Smaller font for details */
             color: #555;
             text-align: center;
             line-height: 1.2;
             white-space: normal;
             word-break: break-word;
             max-width: 100%;
             margin-top: 2px; /* Space above introducer/reason */
         }


        .link {
            fill: none;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 1.5px; /* Increased line thickness */
        }

        .group-box {
            fill: none; /* No fill */
            stroke: #ccc; /* Light gray border */
            stroke-width: 1px;
            stroke-dasharray: 5,5; /* Dashed line */
            rx: 15; /* Rounded corners */
            ry: 15;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆãƒ»ã‚°ãƒ«ãƒ¼ãƒ—é‡ãªã‚Šè§£æ¶ˆï¼‹ç®±ï¼‰</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // ã“ã“ã‚’GitHubã®Rawtherapee URLã«å¤‰æ›´ã—ã¦ãã ã•ã„
        const JSON_FILE_PATH = 'tree_data.json'; // Replace with your actual GitHub Raw URL

        window.addEventListener("DOMContentLoaded", () => {
            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
                        return;
                    }

                    // Group data by introduction_reason for separate trees
                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "ãã®ä»–");

                    const svg = d3.select("#tree-svg");
                    const chartContainer = d3.select("#chart-container");
                    const margin = {top: 60, right: 40, bottom: 60, left: 40}; // Increased margins for box padding
                    const nodeWidth = 120; // Matches .node-card width
                    const nodeHeight = 80; // Approximate height of .node-card content
                    const verticalSpacing = 80; // Increased space between parent and child levels
                    const horizontalSpacing = 30; // Increased minimum space between sibling nodes
                    const groupSpacing = 150; // Space between different groups (Adjust this value)
                    const boxPadding = 30; // Padding inside the group box

                    let currentYOffset = margin.top;
                    let maxSvgWidth = 0;

                    // Create a main group to hold all group subtrees and boxes
                    const mainG = svg.append("g");

                    // Sort groups by reason for consistent order (optional)
                    const sortedGroups = Array.from(groupedData).sort((a, b) => a[0].localeCompare(b[0]));


                    sortedGroups.forEach(([reason, groupData]) => {
                         // Find the root node(s) for this group (introducerPageId is null within this group's data)
                         const rootNodesData = groupData.filter(d => d.introducerPageId === null);

                         // --- Calculate Group Dimensions (before drawing) ---
                         let groupMinX = Infinity, groupMaxX = -Infinity;
                         let groupMinY = Infinity, groupMaxY = -Infinity;
                         let groupCalculatedWidth = 0; // Width needed for layout
                         let groupCalculatedHeight = 0; // Height needed for layout

                         // To calculate group dimensions, we need to layout each subtree within the group
                         // and find the overall extent.
                         const tempSubtreeLayouts = [];

                         rootNodesData.forEach(rootData => {
                             const tempRoot = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));
                             const tempTreeLayout = d3.tree()
                                 .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]);
                             tempTreeLayout(tempRoot);
                             tempSubtreeLayouts.push(tempRoot);

                             // Calculate extent for this subtree
                             let x0 = Infinity, x1 = -Infinity, y0 = Infinity, y1 = -Infinity;
                             tempRoot.each(d => {
                                 // Account for node card size when calculating extent
                                 const halfNodeWidth = nodeWidth / 2;
                                 const halfNodeHeight = nodeHeight / 2;
                                 if (d.x - halfNodeWidth < x0) x0 = d.x - halfNodeWidth;
                                 if (d.x + halfNodeWidth > x1) x1 = d.x + halfNodeWidth;
                                 if (d.y - halfNodeHeight < y0) y0 = d.y - halfNodeHeight;
                                 if (d.y + halfNodeHeight > y1) y1 = d.y + halfNodeHeight;
                             });

                             // Update overall group extent
                             if (x0 < groupMinX) groupMinX = x0;
                             if (x1 > groupMaxX) groupMaxX = x1;
                             if (y0 < groupMinY) groupMinY = y0;
                             if (y1 > groupMaxY) groupMaxY = y1;
                         });

                         // Calculate layout width and height based on extents
                         groupCalculatedWidth = groupMaxX - groupMinX;
                         groupCalculatedHeight = groupMaxY - groupMinY;


                         // Update the overall max SVG width needed
                         if (groupCalculatedWidth + margin.left + margin.right > maxSvgWidth) {
                             maxSvgWidth = groupCalculatedWidth + margin.left + margin.right;
                         }


                         // --- Draw Group Elements ---

                         // Create a group specifically for this group's content (box, title, subtrees)
                         // Position this group using the currentYOffset
                         const groupG = mainG.append("g")
                             .attr("transform", `translate(${margin.left}, ${currentYOffset})`); // Apply margin and currentYOffset


                         // Add the group box (rectangle)
                         groupG.append("rect")
                             .attr("class", "group-box")
                             .attr("x", groupMinX - boxPadding) // Apply padding
                             .attr("y", groupMinY - boxPadding) // Apply padding
                             .attr("width", groupCalculatedWidth + boxPadding * 2) // Add padding to width
                             .attr("height", groupCalculatedHeight + boxPadding * 2); // Add padding to height


                         // Add the group title
                         groupG.append("text")
                             .attr("x", groupMinX - boxPadding) // Position title relative to box
                             .attr("y", groupMinY - boxPadding - (groupSpacing / 2) + (boxPadding / 2)) // Position above the box
                             .attr("dy", "0.35em")
                             .style("font-weight", "bold")
                             .text(reason);


                         // Draw each subtree within this groupG
                         tempSubtreeLayouts.forEach(root => { // Use the pre-calculated layouts
                             // Calculate the horizontal offset to center the subtree within the *group's* calculated width
                             let x0 = Infinity, x1 = -Infinity;
                             root.each(d => {
                                 const halfNodeWidth = nodeWidth / 2;
                                 if (d.x - halfNodeWidth < x0) x0 = d.x - halfNodeWidth;
                                 if (d.x + halfNodeWidth > x1) x1 = d.x + halfNodeWidth;
                             });
                             const subtreeWidth = x1 - x0; // Width of the subtree's nodes
                             const offsetX = (groupCalculatedWidth / 2) - ((x1 + x0) / 2); // Center relative to group width


                             // Create a group for the current subtree within the groupG
                             const subtreeG = groupG.append("g")
                                 .attr("transform", `translate(${offsetX - groupMinX}, ${-groupMinY})`); // Translate relative to group's minX/minY


                             // Draw links
                             subtreeG.append("g")
                                 .attr("fill", "none")
                                 .attr("stroke-linejoin", "round")
                                 .attr("stroke-width", 1.5) /* Increased line thickness */
                                 .selectAll("path")
                                 .data(root.links())
                                 .join("path")
                                 .attr("class", "link")
                                 .attr("d", d3.linkVertical()
                                     .x(d => d.x)
                                     .y(d => d.y)
                                 );

                             // Draw nodes
                             const node = subtreeG.append("g")
                                 .selectAll("g")
                                 .data(root.descendants())
                                 .join("g")
                                 .attr("transform", d => `translate(${d.x},${d.y})`);

                             // Append foreignObject for HTML content
                             const nodeCard = node.append("foreignObject")
                                 .attr("x", -(nodeWidth / 2)) // Center the foreignObject horizontally
                                 .attr("y", -(nodeHeight / 2)) // Center the foreignObject vertically (approx)
                                 .attr("width", nodeWidth)
                                 .attr("height", nodeHeight)
                                 .append("xhtml:div")
                                 .attr("class", "node-card");

                             // Add link wrapper if URL exists
                             const linkWrapper = nodeCard.append("a")
                                 .attr("href", d => d.data.url || "#") // Use 'url' field for link
                                 .attr("target", "_blank"); // Open in new tab

                             // Add image or placeholder
                             linkWrapper.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.image) {
                                     container.append("img")
                                         .attr("class", "node-image")
                                         .attr("src", d.data.image)
                                         .attr("alt", "photo");
                                 } else {
                                     container.append("div")
                                         .attr("class", "node-placeholder")
                                         .text(d.data.name ? d.data.name.charAt(0) : '?');
                                 }
                             });


                             // Add text content (name, introducer, reason)
                             const textContent = linkWrapper.append("div"); // Put text inside the link
                             textContent.append("div")
                                 .attr("class", "node-name")
                                 .text(d => d.data.name);

                             textContent.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.introducer_name) {
                                     container.append("div")
                                         .attr("class", "node-introducer")
                                         .text(`ç´¹ä»‹è€…: ${d.data.introducer_name}`);
                                 }
                             });

                         }); // End drawing rootNodesData.forEach

                         // After processing and drawing all roots and the box in a group,
                         // add the total height of the group (including box padding and title space)
                         // to the currentYOffset for the next group, plus the group spacing.
                         const totalGroupHeightNeeded = groupCalculatedHeight + boxPadding * 2 + groupSpacing;
                         currentYOffset += totalGroupHeightNeeded;


                    }); // End groupedData.forEach

                    // Adjust SVG width and height based on content
                    svg.attr("width", maxSvgWidth); // maxSvgWidth already includes margins
                    svg.attr("height", currentYOffset); // Use the final currentYOffset


                    // ğŸŒŸ ä¸­å¤®ã«è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ 
                    const containerElement = document.getElementById("chart-container");
                    // Use a slight delay to ensure rendering is complete before scrolling
                     setTimeout(() => {
                         containerElement.scrollLeft = (svg.attr("width") - containerElement.clientWidth) / 2;
                     }, 100);


                })
                .catch(error => {
                    console.error('Error fetching JSON data:', error);
                    document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚GitHubã®Rawtherapee URLãŒæ­£ã—ã„ã‹ã€ã¾ãŸã¯CORSã®å•é¡ŒãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>";
                });
        });

         // Optional: Redraw on window resize (more complex with D3 layout)
         // For simplicity, we'll skip full redraw on resize for this example.
         // A robust solution would recalculate layout and redraw SVG on resize.

    </script>
</body>
</html>
