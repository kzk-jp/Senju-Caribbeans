<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆï¼‰</title>
    <style>
        body {
            margin: 0;
            font-family: "Helvetica Neue", sans-serif;
            background-color: #f3f4f6;
            color: #333;
        }

        h1 {
            text-align: center;
            padding: 1rem;
            margin: 0;
            font-size: 1.4rem;
            background: #2563eb; /* blue-700 */
            color: white;
        }

        #chart-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 1rem 0.5rem;
            box-sizing: border-box; /* Include padding in width */
        }

        svg {
            display: block; /* Remove extra space below svg */
            margin: 0 auto; /* Center SVG if wider than container */
        }

        .node-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 12px; /* rounded-xl */
            padding: 8px; /* Increased padding slightly */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            width: 120px; /* Increased width slightly */
            box-sizing: border-box; /* Include padding and border in width */
            text-align: center;
        }

        .node-card a {
             text-decoration: none; /* Remove underline from links */
             color: inherit; /* Inherit text color */
             display: flex; /* Use flexbox for link content */
             flex-direction: column; /* Stack content vertically within link */
             align-items: center; /* Center content horizontally within link */
             width: 100%; /* Make link fill the card width */
        }


        .node-image {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 6px; /* Increased space below image */
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

         .node-placeholder {
             width: 50px;
             height: 50px;
             border-radius: 50%;
             background-color: #d1d5db; /* bg-gray-300 */
             display: flex;
             align-items: center;
             justify-content: center;
             color: #4b5563; /* text-gray-600 */
             font-weight: bold; /* font-bold */
             font-size: 1rem; /* Increased font size */
             margin-bottom: 6px; /* Increased space below placeholder */
         }


        .node-name {
            font-size: 11px; /* Increased font size slightly */
            text-align: center;
            font-weight: 600; /* Increased font weight */
            line-height: 1.3; /* Adjusted line height */
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            max-width: 100%; /* Ensure name fits within card */
        }

         .node-introducer, .node-reason {
             font-size: 9px; /* Smaller font for details */
             color: #555;
             text-align: center;
             line-height: 1.2;
             white-space: normal;
             word-break: break-word;
             max-width: 100%;
             margin-top: 2px; /* Space above introducer/reason */
         }


        .link {
            fill: none;
            stroke: #94a3b8; /* slate-400 */
            stroke-width: 1.5px; /* Increased line thickness */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <h1>ãƒ•ãƒƒãƒˆã‚µãƒ«ãƒ¡ãƒ³ãƒãƒ¼ç´¹ä»‹ãƒ„ãƒªãƒ¼ï¼ˆD3.jsç‰ˆï¼‰</h1>
    <div id="chart-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
        // ã“ã“ã‚’GitHubã®Rawtherapee URLã«å¤‰æ›´ã—ã¦ãã ã•ã„
        const JSON_FILE_PATH = 'tree_data.json'; // Replace with your actual GitHub Raw URL

        window.addEventListener("DOMContentLoaded", () => {
            fetch(JSON_FILE_PATH)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!Array.isArray(jsonData)) {
                        document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
                        return;
                    }

                    // Group data by introduction_reason for separate trees
                    const groupedData = d3.group(jsonData, d => d.introduction_reason || "ãã®ä»–");

                    const svg = d3.select("#tree-svg");
                    const chartContainer = d3.select("#chart-container");
                    const margin = {top: 40, right: 20, bottom: 40, left: 20}; // Adjusted margins
                    const nodeWidth = 120; // Matches .node-card width
                    const nodeHeight = 80; // Approximate height of .node-card content
                    const verticalSpacing = 50; // Space between parent and child levels
                    const horizontalSpacing = 20; // Minimum space between sibling nodes

                    let currentYOffset = margin.top;
                    let maxSvgWidth = 0;

                    // Create a main group to hold all group subtrees
                    const mainG = svg.append("g");

                    groupedData.forEach((groupData, reason) => {
                        // Find the root node(s) for this group (introducerPageId is null within this group's data)
                        // Note: D3 hierarchy typically expects a single root. If a group has multiple
                        // members with introducerPageId === null, they will be treated as separate roots
                        // within this group's processing, but we'll append them sequentially.
                         const rootNodesData = groupData.filter(d => d.introducerPageId === null);

                         rootNodesData.forEach(rootData => {
                             // Build the hierarchy for this root and its descendants
                             const root = d3.hierarchy(rootData, d => jsonData.filter(item => item.introducerPageId === d.id));

                             // Define the tree layout
                             const treeLayout = d3.tree()
                                 .nodeSize([nodeHeight + verticalSpacing, nodeWidth + horizontalSpacing]); // [vertical, horizontal] spacing

                             // Compute the layout
                             treeLayout(root);

                             // Calculate the extent of the subtree for positioning
                             let x0 = Infinity, x1 = -Infinity;
                             root.each(d => {
                                 if (d.x < x0) x0 = d.x;
                                 if (d.x > x1) x1 = d.x;
                             });

                             // Calculate the width of the subtree
                             const subtreeWidth = x1 - x0 + nodeWidth + horizontalSpacing;
                             if (subtreeWidth > maxSvgWidth) {
                                 maxSvgWidth = subtreeWidth;
                             }

                             // Calculate the horizontal offset to center the subtree (initially)
                             // This centering might be relative to the maxSvgWidth or the container width
                             // Let's center relative to the potential max width for consistent horizontal alignment
                             const offsetX = (maxSvgWidth / 2) - ((x1 + x0) / 2);


                             // Create a group for the current subtree
                             const subtreeG = mainG.append("g")
                                 .attr("transform", `translate(${margin.left + offsetX}, ${currentYOffset})`); // Apply margin and calculated offset

                             // Draw links
                             subtreeG.append("g")
                                 .attr("fill", "none")
                                 .attr("stroke-linejoin", "round")
                                 .attr("stroke-width", 1.5) /* Increased line thickness */
                                 .selectAll("path")
                                 .data(root.links())
                                 .join("path")
                                 .attr("class", "link")
                                 .attr("d", d3.linkVertical()
                                     .x(d => d.x)
                                     .y(d => d.y)
                                 );

                             // Draw nodes
                             const node = subtreeG.append("g")
                                 .selectAll("g")
                                 .data(root.descendants())
                                 .join("g")
                                 .attr("transform", d => `translate(${d.x},${d.y})`);

                             // Append foreignObject for HTML content
                             const nodeCard = node.append("foreignObject")
                                 .attr("x", -(nodeWidth / 2)) // Center the foreignObject horizontally
                                 .attr("y", -(nodeHeight / 2)) // Center the foreignObject vertically (approx)
                                 .attr("width", nodeWidth)
                                 .attr("height", nodeHeight)
                                 .append("xhtml:div")
                                 .attr("class", "node-card");

                             // Add link wrapper if URL exists
                             const linkWrapper = nodeCard.append("a")
                                 .attr("href", d => d.data.url || "#") // Use 'url' field for link
                                 .attr("target", "_blank"); // Open in new tab

                             // Add image or placeholder
                             linkWrapper.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.image) {
                                     container.append("img")
                                         .attr("class", "node-image")
                                         .attr("src", d.data.image)
                                         .attr("alt", "photo");
                                 } else {
                                     container.append("div")
                                         .attr("class", "node-placeholder")
                                         .text(d.data.name ? d.data.name.charAt(0) : '?');
                                 }
                             });


                             // Add text content (name, introducer, reason)
                             const textContent = linkWrapper.append("div"); // Put text inside the link
                             textContent.append("div")
                                 .attr("class", "node-name")
                                 .text(d => d.data.name);

                             textContent.each(function(d) {
                                 const container = d3.select(this);
                                 if (d.data.introducer_name) {
                                     container.append("div")
                                         .attr("class", "node-introducer")
                                         .text(`ç´¹ä»‹è€…: ${d.data.introducer_name}`);
                                 }
                                 // Reason is used for grouping title, might not be needed on every card
                                 /*
                                 if (d.data.introduction_reason) {
                                      container.append("div")
                                          .attr("class", "node-reason")
                                          .text(`(${d.data.introduction_reason})`);
                                  }
                                  */
                             });


                             // Add space for the next subtree
                             currentYOffset += root.height * (nodeHeight + verticalSpacing) + margin.bottom + verticalSpacing; // Calculate height based on subtree depth

                         }); // End rootNodesData.forEach
                    }); // End groupedData.forEach

                    // Adjust SVG width and height based on content
                    svg.attr("width", maxSvgWidth + margin.left + margin.right);
                    svg.attr("height", currentYOffset + margin.bottom);


                    // ğŸŒŸ ä¸­å¤®ã«è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹å‡¦ç†ã‚’è¿½åŠ 
                    const containerElement = document.getElementById("chart-container");
                    // Use a slight delay to ensure rendering is complete before scrolling
                     setTimeout(() => {
                         containerElement.scrollLeft = (svg.attr("width") - containerElement.clientWidth) / 2;
                     }, 100);


                })
                .catch(error => {
                    console.error('Error fetching JSON data:', error);
                    document.getElementById("chart-container").innerHTML = "<p>ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚GitHubã®Rawtherapee URLãŒæ­£ã—ã„ã‹ã€ã¾ãŸã¯CORSã®å•é¡ŒãŒãªã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>";
                });
        });

         // Optional: Redraw on window resize (more complex with D3 layout)
         // For simplicity, we'll skip full redraw on resize for this example.
         // A robust solution would recalculate layout and redraw SVG on resize.

    </script>
</body>
</html>
